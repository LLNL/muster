<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Muster: cluster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cluster Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Namespace for everything in the cluster library.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1counter__iterator.html">counter_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counting output iterator that records how many times an output iterator was assigned to, but ignores the value stored.  <a href="structcluster_1_1counter__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1matrix__distance.html">matrix_distance</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor for passing a matrix by reference to template functions that take a callable distance function.  <a href="structcluster_1_1matrix__distance.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1lazy__distance__functor.html">lazy_distance_functor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor for computing distance lazily from an object array and a distance metric.  <a href="structcluster_1_1lazy__distance__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1id__pair.html">id_pair</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MPI-packable struct for an MPI-packable type plus its object id.  <a href="structcluster_1_1id__pair.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html">kmedoids</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementations of the classic clustering algorithms PAM and CLARA, from <em>Finding Groups in Data</em>, by Kaufman and Rousseeuw.  <a href="classcluster_1_1kmedoids.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1multi__gather.html">multi_gather</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous, some-to-some gather operation used by parallel clustering algorithms to simultaneously send members of sample sets to a set of distributed worker processes.  <a href="classcluster_1_1multi__gather.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1par__kmedoids.html">par_kmedoids</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements the CAPEK and XCAPEK scalable parallel clustering algorithms.  <a href="classcluster_1_1par__kmedoids.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1par__partition.html">par_partition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structcluster_1_1par__partition.html" title="par_partition represents a partitioning of a distributed data set.">par_partition</a> represents a partitioning of a distributed data set.  <a href="structcluster_1_1par__partition.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1partition.html">partition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This represents a partitioning of a data set.  <a href="structcluster_1_1partition.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcluster_1_1trial.html">trial</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This struct represents parameters for a single trial run of kmedoids.  <a href="structcluster_1_1trial.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1trial__generator.html">trial_generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to generate a set of trials for clustering.  <a href="classcluster_1_1trial__generator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::numeric::ublas::symmetric_matrix<br class="typebreak"/>
&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packed repersentation of symmetric dissimilarity matrix.  <a href="#a3da8b7c34d3e5089d88d0a8760a4d57c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">More descriptive type for medoid index.  <a href="#aea622505d1fa9f4641796167e37f1092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">More descriptive type for object index.  <a href="#abe52518c0b3d1e6319b0b994ed58a315"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::set<br class="typebreak"/>
&lt; <a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicit representation of a clustering.  <a href="#ab8aaff667d0c1d5dd7aa94e0c1a237d9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#af654c630dfe169d9f005f16956ed293f">bic</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;p, D distance, size_t M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directly computes the BIC from a partition object based on the cluster centroids and the number of clusters.  <a href="#af654c630dfe169d9f005f16956ed293f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeIterator , typename DissimIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a327e81307cb0a7cf71231c807cd0ac98">bic</a> (size_t k, SizeIterator cluster_sizes, DissimIterator sum2_dissim, size_t dimensionality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This version of the BIC assumes some precomputed information.  <a href="#a327e81307cb0a7cf71231c807cd0ac98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcluster_1_1counter__iterator.html">counter_iterator</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ac54b0106a8c56625c4fb5967d5a71cef">counter</a> (T &amp;ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor for creating type-inferred counters.  <a href="#ac54b0106a8c56625c4fb5967d5a71cef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ac42a89b1657078539345f7ff233803cd">build_dissimilarity_matrix</a> (const std::vector&lt; T &gt; &amp;objects, D dissimilarity, <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a dissimilarity matrix from a vector of objects.  <a href="#ac42a89b1657078539345f7ff233803cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a0dc465d088b94c2f64d9b62281b70dcf">build_dissimilarity_matrix</a> (const std::vector&lt; T &gt; &amp;objects, const std::vector&lt; size_t &gt; &amp;subset, D dissimilarity, <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a dissimilarity matrix from a subset of a vector of objects.  <a href="#a0dc465d088b94c2f64d9b62281b70dcf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcluster_1_1lazy__distance__functor.html">lazy_distance_functor</a>&lt; T, D &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#afc0582c6226e51fd6f01d5d542364b27">lazy_distance</a> (const std::vector&lt; T &gt; &amp;objs, D dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type-inferred syntactic sugar for constructing <a class="el" href="structcluster_1_1lazy__distance__functor.html" title="Functor for computing distance lazily from an object array and a distance metric.">lazy_distance_functor</a>.  <a href="#afc0582c6226e51fd6f01d5d542364b27"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcluster_1_1id__pair.html">id_pair</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a3e7c255cedb29a255f3907f9037d182a">make_id_pair</a> (const T &amp;elt, int id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for making arbitrary id_pairs with type inference.  <a href="#a3e7c255cedb29a255f3907f9037d182a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a48cb342d6385d2bd99366247e0269c53">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structcluster_1_1id__pair.html">id_pair</a>&lt; T &gt; &amp;p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out an <a class="el" href="structcluster_1_1id__pair.html" title="MPI-packable struct for an MPI-packable type plus its object id.">id_pair</a> as a tuple of its element and its source rank.  <a href="#a48cb342d6385d2bd99366247e0269c53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ae77e03ee1b9ba922ee625f75ba1a9e40">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structcluster_1_1par__partition.html">par_partition</a> &amp;par)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right now this just uses parition::operator&lt;&lt;() by making a partition with this par_partition's cluster_ids and medoid_ids vectors and outputting it.  <a href="#ae77e03ee1b9ba922ee625f75ba1a9e40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a5b75b213c71b65b582ce7349f0f0bbab">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a> &amp;clusters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ac6317ef2a7029b335c084d6501d3a8ad">mirkin_distance</a> (const <a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a> &amp;c1, const <a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a> &amp;c2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mirkin distance bt/w two clusterings.  <a href="#ac6317ef2a7029b335c084d6501d3a8ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a36b6fe30f0faa91948b108c115309066">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;km)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For convenience.  <a href="#a36b6fe30f0faa91948b108c115309066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#abeae85bb59ffca3d19e380b47000d192">mirkin_distance</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;c1, const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;c2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for comparing partition objects directly.  <a href="#abeae85bb59ffca3d19e380b47000d192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ae9b520de376d157f863f2c6a71d9db89">expand</a> (<a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a> &amp;list, size_t level=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand a cluster_list by l levels.  <a href="#ae9b520de376d157f863f2c6a71d9db89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a9a95ddb94be045b5e43e8b5182a8cb9e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structcluster_1_1partition_1_1member__writer.html">partition::member_writer</a> &amp;mw)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#aa307d3aeb404b4900478414c330585b1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a> &amp;list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints out nicely formatted clustering.  <a href="#aa307d3aeb404b4900478414c330585b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a4a078c24f11b876a18e1ea7780f58a4e">total_dissimilarity</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;p, D dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the total dissimilarity between all objects and their medoids.  <a href="#a4a078c24f11b876a18e1ea7780f58a4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#ac1dc9b626241e4bb0bbfc8ec6c2c5dd4">total_dissimilarity</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;p, D dist, <a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the total dissimilarity between all objects in a particular cluster and its medoid.  <a href="#ac1dc9b626241e4bb0bbfc8ec6c2c5dd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#add265e8aae9c95c0cf9b5498772494d9">total_squared_dissimilarity</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;p, D dist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the total squared dissimilarity between all objects and their medoids.  <a href="#add265e8aae9c95c0cf9b5498772494d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a1790e80a7a567f5d4198e89a74fd5d68">total_squared_dissimilarity</a> (const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;p, D dist, <a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a> m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the total squared dissimilarity between all objects in a particular cluster and its medoid.  <a href="#a1790e80a7a567f5d4198e89a74fd5d68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class OutputIterator , class Random &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a5a49ac83447a427e107632127220ebc8">random_subset</a> (size_t numElements, size_t sample_size, OutputIterator out, Random &amp;random)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is Knuth's algorithm R for taking a sample of indices from 0 to numElements.  <a href="#a5a49ac83447a427e107632127220ebc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecluster.html#a849e4e0e478e64ac1bb00039b251f384">get_time_seed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reasonably distributed seed for random number generators.  <a href="#a849e4e0e478e64ac1bb00039b251f384"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Namespace for everything in the cluster library. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ab8aaff667d0c1d5dd7aa94e0c1a237d9"></a><!-- doxytag: member="cluster::cluster_list" ref="ab8aaff667d0c1d5dd7aa94e0c1a237d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; std::set&lt;<a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a>&gt; &gt; <a class="el" href="namespacecluster.html#ab8aaff667d0c1d5dd7aa94e0c1a237d9">cluster_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicit representation of a clustering. </p>
<p>Instead of a vecto of representative ids, this has <em>k</em> sets of object_ids indicating which objects are in a particular cluster. You can convert a partition to a cluster_list with to_cluster_list(). </p>

</div>
</div>
<a class="anchor" id="a3da8b7c34d3e5089d88d0a8760a4d57c"></a><!-- doxytag: member="cluster::dissimilarity_matrix" ref="a3da8b7c34d3e5089d88d0a8760a4d57c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::numeric::ublas::symmetric_matrix&lt;double&gt; <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Packed repersentation of symmetric dissimilarity matrix. </p>

</div>
</div>
<a class="anchor" id="aea622505d1fa9f4641796167e37f1092"></a><!-- doxytag: member="cluster::medoid_id" ref="aea622505d1fa9f4641796167e37f1092" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>More descriptive type for medoid index. </p>

</div>
</div>
<a class="anchor" id="abe52518c0b3d1e6319b0b994ed58a315"></a><!-- doxytag: member="cluster::object_id" ref="abe52518c0b3d1e6319b0b994ed58a315" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>More descriptive type for object index. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af654c630dfe169d9f005f16956ed293f"></a><!-- doxytag: member="cluster::bic" ref="af654c630dfe169d9f005f16956ed293f" args="(const partition &amp;p, D distance, size_t M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::bic </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directly computes the BIC from a partition object based on the cluster centroids and the number of clusters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>A partition object describing the clustering to be evaluated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>A distance function callable on two <em>indices</em> from the partition p. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>M</em>&nbsp;</td><td>Dimensionality parameter -- degrees of freedom in the input dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid BIC score based on the input parameters. Higher numbers indicate better fit. </dd></dl>

</div>
</div>
<a class="anchor" id="a327e81307cb0a7cf71231c807cd0ac98"></a><!-- doxytag: member="cluster::bic" ref="a327e81307cb0a7cf71231c807cd0ac98" args="(size_t k, SizeIterator cluster_sizes, DissimIterator sum2_dissim, size_t dimensionality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::bic </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeIterator&nbsp;</td>
          <td class="paramname"> <em>cluster_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DissimIterator&nbsp;</td>
          <td class="paramname"> <em>sum2_dissim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dimensionality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This version of the BIC assumes some precomputed information. </p>
<p>This is useful for parallel implementations, where it is more efficient to compute some global sums as a reduction rather than aggregating a full partition to one process. Here, we assume that the sizes of the distributed clusters as well as the total squared intra-cluster dissimilarity (between each object and its medoid) is known.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>k</em>&nbsp;</td><td>Number of clusters in the clustering. Same as k from k-means or k-medoids. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cluster_sizes</em>&nbsp;</td><td>Start of range of k sizes. <code>*cluster_sizes .. *(cluster_sizes + k)</code> should be the sizes of clusters 1 to k </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sum2_dissim</em>&nbsp;</td><td>Sum of squared dissimilarities of each object w.r.t. its nearest medoid. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimensionality</em>&nbsp;</td><td>Dimensionality of clustered data. e.g., 2 for 2-dimensional points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac42a89b1657078539345f7ff233803cd"></a><!-- doxytag: member="cluster::build_dissimilarity_matrix" ref="ac42a89b1657078539345f7ff233803cd" args="(const std::vector&lt; T &gt; &amp;objects, D dissimilarity, dissimilarity_matrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cluster::build_dissimilarity_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dissimilarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dissimilarity_matrix &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a dissimilarity matrix from a vector of objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>objects</em>&nbsp;</td><td>Vector of any type T. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dissimilarity</em>&nbsp;</td><td>A dissimilarity measure that gives the distance between two T's. Needs to be callable on (T, T). </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Output parameter. Dissimiliarity matrix is stored here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dc465d088b94c2f64d9b62281b70dcf"></a><!-- doxytag: member="cluster::build_dissimilarity_matrix" ref="a0dc465d088b94c2f64d9b62281b70dcf" args="(const std::vector&lt; T &gt; &amp;objects, const std::vector&lt; size_t &gt; &amp;subset, D dissimilarity, dissimilarity_matrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cluster::build_dissimilarity_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dissimilarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dissimilarity_matrix &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a dissimilarity matrix from a subset of a vector of objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>objects</em>&nbsp;</td><td>Vector of any type T. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subset</em>&nbsp;</td><td>Indirection vector. Contains indices into objects for elements to be compared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dissimilarity</em>&nbsp;</td><td>A dissimilarity measure that gives the distance between two T's. Needs to be callable(T, T). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Output parameter. Dissimiliarity matrix is stored here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac54b0106a8c56625c4fb5967d5a71cef"></a><!-- doxytag: member="cluster::counter" ref="ac54b0106a8c56625c4fb5967d5a71cef" args="(T &amp;ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcluster_1_1counter__iterator.html">counter_iterator</a>&lt;T&gt; cluster::counter </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adaptor for creating type-inferred counters. </p>
<p><b>Example Usage:</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;algorithm&gt;</span>
 
 <span class="comment">// construct two sets</span>
 set&lt;int&gt; s1, s2;
 
 <span class="comment">// insert some things so that their intersection has 2 ints.</span>
 s1.insert(1); s1.insert(2); s1.insert(3);
 s2.insert(2); s2.insert(3); s2.insert(4);
 
 <span class="comment">// Compute intersection, but throw away the values and just </span>
 <span class="comment">// store the size in the count variable.</span>
 <span class="keywordtype">size_t</span> count;
 set_intersection(s1.begin(), s1.end(), 
                  s2.begin(), s2.end(), <a class="code" href="namespacecluster.html#ac54b0106a8c56625c4fb5967d5a71cef" title="Adaptor for creating type-inferred counters.">counter</a>(count));

 <span class="comment">// now count == 2, since 2 items were inserted </span>
 <span class="comment">// by &lt;code&gt;set_intersection.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ae9b520de376d157f863f2c6a71d9db89"></a><!-- doxytag: member="cluster::expand" ref="ae9b520de376d157f863f2c6a71d9db89" args="(cluster_list &amp;list, size_t level=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void expand </td>
          <td>(</td>
          <td class="paramtype">cluster_list &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a cluster_list by l levels. </p>
<p>That is, replace each index i in the cluster_list with indices in [2^l * i ... 2^l * (i+1) - 1]</p>

</div>
</div>
<a class="anchor" id="a849e4e0e478e64ac1bb00039b251f384"></a><!-- doxytag: member="cluster::get_time_seed" ref="a849e4e0e478e64ac1bb00039b251f384" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cluster::get_time_seed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reasonably distributed seed for random number generators. </p>
<p>Based on the product of the seconds and usec in gettimeofday(). </p>

</div>
</div>
<a class="anchor" id="afc0582c6226e51fd6f01d5d542364b27"></a><!-- doxytag: member="cluster::lazy_distance" ref="afc0582c6226e51fd6f01d5d542364b27" args="(const std::vector&lt; T &gt; &amp;objs, D dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcluster_1_1lazy__distance__functor.html">lazy_distance_functor</a>&lt;T,D&gt; cluster::lazy_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type-inferred syntactic sugar for constructing <a class="el" href="structcluster_1_1lazy__distance__functor.html" title="Functor for computing distance lazily from an object array and a distance metric.">lazy_distance_functor</a>. </p>

</div>
</div>
<a class="anchor" id="a3e7c255cedb29a255f3907f9037d182a"></a><!-- doxytag: member="cluster::make_id_pair" ref="a3e7c255cedb29a255f3907f9037d182a" args="(const T &amp;elt, int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcluster_1_1id__pair.html">id_pair</a>&lt;T&gt; cluster::make_id_pair </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for making arbitrary id_pairs with type inference. </p>

</div>
</div>
<a class="anchor" id="ac6317ef2a7029b335c084d6501d3a8ad"></a><!-- doxytag: member="cluster::mirkin_distance" ref="ac6317ef2a7029b335c084d6501d3a8ad" args="(const cluster_list &amp;c1, const cluster_list &amp;c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mirkin_distance </td>
          <td>(</td>
          <td class="paramtype">const cluster_list &amp;&nbsp;</td>
          <td class="paramname"> <em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cluster_list &amp;&nbsp;</td>
          <td class="paramname"> <em>c2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mirkin distance bt/w two clusterings. </p>

</div>
</div>
<a class="anchor" id="abeae85bb59ffca3d19e380b47000d192"></a><!-- doxytag: member="cluster::mirkin_distance" ref="abeae85bb59ffca3d19e380b47000d192" args="(const partition &amp;c1, const partition &amp;c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mirkin_distance </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>c2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for comparing partition objects directly. </p>

</div>
</div>
<a class="anchor" id="a48cb342d6385d2bd99366247e0269c53"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="a48cb342d6385d2bd99366247e0269c53" args="(std::ostream &amp;out, const id_pair&lt; T &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; cluster::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const id_pair&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out an <a class="el" href="structcluster_1_1id__pair.html" title="MPI-packable struct for an MPI-packable type plus its object id.">id_pair</a> as a tuple of its element and its source rank. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>inferred from the id_pair&lt;T&gt; this is called on. Must support operator&lt;&lt;.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Output stream to write the <a class="el" href="structcluster_1_1id__pair.html" title="MPI-packable struct for an MPI-packable type plus its object id.">id_pair</a> p onto </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>An id_pair&lt;T&gt;. T must support operator&lt;&lt;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a95ddb94be045b5e43e8b5182a8cb9e"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="a9a95ddb94be045b5e43e8b5182a8cb9e" args="(std::ostream &amp;out, const partition::member_writer &amp;mw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; cluster::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const partition::member_writer &amp;&nbsp;</td>
          <td class="paramname"> <em>mw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae77e03ee1b9ba922ee625f75ba1a9e40"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="ae77e03ee1b9ba922ee625f75ba1a9e40" args="(std::ostream &amp;out, const par_partition &amp;par)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const par_partition &amp;&nbsp;</td>
          <td class="paramname"> <em>par</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Right now this just uses parition::operator&lt;&lt;() by making a partition with this par_partition's cluster_ids and medoid_ids vectors and outputting it. </p>

</div>
</div>
<a class="anchor" id="a5b75b213c71b65b582ce7349f0f0bbab"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="a5b75b213c71b65b582ce7349f0f0bbab" args="(ostream &amp;out, const cluster_list &amp;clusters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; cluster::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cluster_list &amp;&nbsp;</td>
          <td class="paramname"> <em>clusters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36b6fe30f0faa91948b108c115309066"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="a36b6fe30f0faa91948b108c115309066" args="(std::ostream &amp;out, const partition &amp;km)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For convenience. </p>

</div>
</div>
<a class="anchor" id="aa307d3aeb404b4900478414c330585b1"></a><!-- doxytag: member="cluster::operator&lt;&lt;" ref="aa307d3aeb404b4900478414c330585b1" args="(std::ostream &amp;out, const cluster_list &amp;list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; cluster::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cluster_list &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints out nicely formatted clustering. </p>

</div>
</div>
<a class="anchor" id="a5a49ac83447a427e107632127220ebc8"></a><!-- doxytag: member="cluster::random_subset" ref="a5a49ac83447a427e107632127220ebc8" args="(size_t numElements, size_t sample_size, OutputIterator out, Random &amp;random)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cluster::random_subset </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sample_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Random &amp;&nbsp;</td>
          <td class="paramname"> <em>random</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is Knuth's algorithm R for taking a sample of indices from 0 to numElements. </p>
<p>We sample size indices from this (the superset) and put them in the subset's mapping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>total number of elements to select from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sample_size</em>&nbsp;</td><td>number of elements to select </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>destination for selected elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>random</em>&nbsp;</td><td>model of STL Random Number Generator. must be callable as random(N), returning a random number in [0,N). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1dc9b626241e4bb0bbfc8ec6c2c5dd4"></a><!-- doxytag: member="cluster::total_dissimilarity" ref="ac1dc9b626241e4bb0bbfc8ec6c2c5dd4" args="(const partition &amp;p, D dist, medoid_id m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::total_dissimilarity </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">medoid_id&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the total dissimilarity between all objects in a particular cluster and its medoid. </p>

</div>
</div>
<a class="anchor" id="a4a078c24f11b876a18e1ea7780f58a4e"></a><!-- doxytag: member="cluster::total_dissimilarity" ref="a4a078c24f11b876a18e1ea7780f58a4e" args="(const partition &amp;p, D dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::total_dissimilarity </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the total dissimilarity between all objects and their medoids. </p>

</div>
</div>
<a class="anchor" id="a1790e80a7a567f5d4198e89a74fd5d68"></a><!-- doxytag: member="cluster::total_squared_dissimilarity" ref="a1790e80a7a567f5d4198e89a74fd5d68" args="(const partition &amp;p, D dist, medoid_id m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::total_squared_dissimilarity </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">medoid_id&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the total squared dissimilarity between all objects in a particular cluster and its medoid. </p>

</div>
</div>
<a class="anchor" id="add265e8aae9c95c0cf9b5498772494d9"></a><!-- doxytag: member="cluster::total_squared_dissimilarity" ref="add265e8aae9c95c0cf9b5498772494d9" args="(const partition &amp;p, D dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cluster::total_squared_dissimilarity </td>
          <td>(</td>
          <td class="paramtype">const partition &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the total squared dissimilarity between all objects and their medoids. </p>

</div>
</div>
</div>
<hr class="footer"/>
<a href="http://www.doxygen.org/">
    <img border="0" src="doxygen.png" align="left" style="margin-right:10px;margin-left:5px;"/>
</a>
<small>
<b>Muster</b>.
Copyright &copy; 2010, <a href="http://www.llnl.gov">Lawrence Livermore National Laboratory</a>,  LLNL-CODE-433662.<br>
Distribution of the Muster documentation is subject to terms of the Muster <a href="http://github.com/tgamblin/muster/blob/master/LICENSE">LICENSE</a>.<br>
Generated on Wed Oct 13 2010 using <a href="http://www.doxygen.org/">Doxygen 1.7.1</a>
</small>

