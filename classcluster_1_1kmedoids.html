<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Muster: kmedoids Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecluster.html">cluster</a>      </li>
      <li><a class="el" href="classcluster_1_1kmedoids.html">kmedoids</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>kmedoids Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cluster::kmedoids" --><!-- doxytag: inherits="cluster::partition" -->
<p>Implementations of the classic clustering algorithms PAM and CLARA, from <em>Finding Groups in Data</em>, by Kaufman and Rousseeuw.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kmedoids_8h_source.html">kmedoids.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for kmedoids:</div>
<div class="dyncontent">
<div class="center"><img src="classcluster_1_1kmedoids__inherit__graph.png" border="0" usemap="#kmedoids_inherit__map" alt="Inheritance graph"/></div>
<map name="kmedoids_inherit__map" id="kmedoids_inherit__map">
<area shape="rect" id="node2" href="structcluster_1_1partition.html" title="This represents a partitioning of a data set." alt="" coords="9,5,84,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for kmedoids:</div>
<div class="dyncontent">
<div class="center"><img src="classcluster_1_1kmedoids__coll__graph.png" border="0" usemap="#kmedoids_coll__map" alt="Collaboration graph"/></div>
<map name="kmedoids_coll__map" id="kmedoids_coll__map">
<area shape="rect" id="node2" href="structcluster_1_1partition.html" title="This represents a partitioning of a data set." alt="" coords="9,5,84,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classcluster_1_1kmedoids-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#afa77c142ddaae7f3050107b16aeb41e8">kmedoids</a> (size_t num_objects=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#afa77c142ddaae7f3050107b16aeb41e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#afd57a631a9379d07ce328ef430218e4c">~kmedoids</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a2822571e1f0d1119f484f45ba7a49ef3">average_dissimilarity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the average dissimilarity of objects w/their medoids for the last run.  <a href="#a2822571e1f0d1119f484f45ba7a49ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a65c8749d81dc0f963a309b14a226d939">set_sort_medoids</a> (bool <a class="el" href="classcluster_1_1kmedoids.html#a84f51d7da6fb7899ecf1bcb3174014d2">sort_medoids</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether medoids will be sorted by object id after clustering is complete.  <a href="#a65c8749d81dc0f963a309b14a226d939"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a419b9d3140b288429149fd13e3b59bf1">set_epsilon</a> (double <a class="el" href="classcluster_1_1kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7">epsilon</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set tolerance for convergence.  <a href="#a419b9d3140b288429149fd13e3b59bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#abb472d7a1325a47b8abde2af0509089c">pam</a> (const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;distance, size_t k, const <a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a> *initial_medoids=NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in Kaufman and Rousseeuw.  <a href="#abb472d7a1325a47b8abde2af0509089c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a5116cf4e711e642a338d783029fdee3e">xpam</a> (const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;distance, size_t max_k, size_t dimensionality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in Kaufman and Rousseeuw.  <a href="#a5116cf4e711e642a338d783029fdee3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#af4ce0293e41923a7ac472202d45f032e">clara</a> (const std::vector&lt; T &gt; &amp;objects, D dmetric, size_t k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CLARA clustering algorithm, as per Kaufman and Rousseuw and R.  <a href="#af4ce0293e41923a7ac472202d45f032e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a8e7c78fbb95db49050dfe89d4fa6ea25">center_medoids</a> (const std::vector&lt; T &gt; &amp;objects, D distance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes existing clustering and reassigns medoids by taking closest medoid to mean of each cluster.  <a href="#a8e7c78fbb95db49050dfe89d4fa6ea25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a309f7bb703fec73b13e2582f0ee35521">xclara</a> (const std::vector&lt; T &gt; &amp;objects, D dmetric, size_t max_k, size_t dimensionality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">K-Agnostic version of CLARA.  <a href="#a309f7bb703fec73b13e2582f0ee35521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a626d40cc1199459d516a63fd8ab314c9">set_init_size</a> (size_t sz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#aeb5df16fa21f073c832b6dc0af5a0f5c">set_max_reps</a> (size_t r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a1d52b3ba9710ea8dca5789326e124411">set_xcallback</a> (void(*)(const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;part, double bic))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set callback function for XPAM and XCLARA. default is none.  <a href="#a1d52b3ba9710ea8dca5789326e124411"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::mt19937&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::random_number_generator<br class="typebreak"/>
&lt; <a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a>, unsigned long &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#abd98da4790855a733e84b4701b1147c8">rng_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Randomness source for this algorithm.  <a href="#abd98da4790855a733e84b4701b1147c8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#ab85094c9fa2a94d0fc0b2ad0a06dd140">init_medoids</a> (size_t k, const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;distance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">KR BUILD algorithm for assigning initial medoids to a partition.  <a href="#ab85094c9fa2a94d0fc0b2ad0a06dd140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#ae16bab558d4b26b7ab72acf006ac0770">cost</a> (<a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a> i, <a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a> h, const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;distance) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total cost of swapping object h with medoid i.  <a href="#ae16bab558d4b26b7ab72acf006ac0770"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a0880d4c07a49c73aaaf6d7a14170f3dd">assign_objects_to_clusters</a> (DM distance)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign each object to the cluster with the closest medoid.  <a href="#a0880d4c07a49c73aaaf6d7a14170f3dd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a33f9ad5daa74665e7f020f8d4f6b16a8">random</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for RNG used in this algorithm.  <a href="#a33f9ad5daa74665e7f020f8d4f6b16a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcluster_1_1kmedoids.html#abd98da4790855a733e84b4701b1147c8">rng_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#ad2ffe85547bbc76ec5fd310505929c7a">rng</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a116dd4dde490d47267f1de54533cee8c">sec_nearest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a752062b45d39866c3b974523a888d220">total_dissimilarity</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of second closest medoids. Used by PAM.  <a href="#a752062b45d39866c3b974523a888d220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a84f51d7da6fb7899ecf1bcb3174014d2">sort_medoids</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total dissimilarity bt/w objects and their medoid.  <a href="#a84f51d7da6fb7899ecf1bcb3174014d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7">epsilon</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether medoids should be canonically sorted by object id.  <a href="#a4904cc82627458fdf6672ccc0b2802c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#a6aad23523234e617409dbf31687f6876">init_size</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalized sensitivity for convergence.  <a href="#a6aad23523234e617409dbf31687f6876"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#af4c641bc801fd71d691835566187f4b3">max_reps</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initial sample size (before 2*k)  <a href="#af4c641bc801fd71d691835566187f4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcluster_1_1kmedoids.html#aac1f10a7a858e6e198f855a0d24a0a84">xcallback</a> )(const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;part, double bic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initial sample size (before 2*k)  <a href="#aac1f10a7a858e6e198f855a0d24a0a84"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementations of the classic clustering algorithms PAM and CLARA, from <em>Finding Groups in Data</em>, by Kaufman and Rousseeuw. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a74d615255c4ed34fb8d88224f645e996"></a><!-- doxytag: member="cluster::kmedoids::random_type" ref="a74d615255c4ed34fb8d88224f645e996" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mt19937 <a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd98da4790855a733e84b4701b1147c8"></a><!-- doxytag: member="cluster::kmedoids::rng_type" ref="abd98da4790855a733e84b4701b1147c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::random_number_generator&lt;<a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a>, unsigned long&gt; <a class="el" href="classcluster_1_1kmedoids.html#abd98da4790855a733e84b4701b1147c8">rng_type</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Randomness source for this algorithm. </p>
<p>Adaptor for STL algorithms. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afa77c142ddaae7f3050107b16aeb41e8"></a><!-- doxytag: member="cluster::kmedoids::kmedoids" ref="afa77c142ddaae7f3050107b16aeb41e8" args="(size_t num_objects=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcluster_1_1kmedoids.html">kmedoids</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>num_objects</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Can optionally specify number of objects to be clustered. and this will start out with all of them in one cluster.</p>
<p>The random number generator associated with this kmedoids object is seeded with the time in microseconds since the epoch. </p>

</div>
</div>
<a class="anchor" id="afd57a631a9379d07ce328ef430218e4c"></a><!-- doxytag: member="cluster::kmedoids::~kmedoids" ref="afd57a631a9379d07ce328ef430218e4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classcluster_1_1kmedoids.html">kmedoids</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0880d4c07a49c73aaaf6d7a14170f3dd"></a><!-- doxytag: member="cluster::kmedoids::assign_objects_to_clusters" ref="a0880d4c07a49c73aaaf6d7a14170f3dd" args="(DM distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double assign_objects_to_clusters </td>
          <td>(</td>
          <td class="paramtype">DM&nbsp;</td>
          <td class="paramname"> <em>distance</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign each object to the cluster with the closest medoid. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total dissimilarity of objects w/their medoids.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>a callable object that computes distances between indices, as a distance matrix would. Algorithms are free to use real distance matrices (as in PAM) or to compute lazily (as in CLARA medoid assignment). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2822571e1f0d1119f484f45ba7a49ef3"></a><!-- doxytag: member="cluster::kmedoids::average_dissimilarity" ref="a2822571e1f0d1119f484f45ba7a49ef3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double average_dissimilarity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the average dissimilarity of objects w/their medoids for the last run. </p>

</div>
</div>
<a class="anchor" id="a8e7c78fbb95db49050dfe89d4fa6ea25"></a><!-- doxytag: member="cluster::kmedoids::center_medoids" ref="a8e7c78fbb95db49050dfe89d4fa6ea25" args="(const std::vector&lt; T &gt; &amp;objects, D distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void center_medoids </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes existing clustering and reassigns medoids by taking closest medoid to mean of each cluster. </p>
<p>This is O(n) and can give better representatives for CLARA clusterings. This is needed to apply gaussian-model BIC criteria to clusterings.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>To use this function, T needs to support algebraic operations.<br/>
 Specifically, T must support enough to construct a mean:</p>
<ul>
<li>addition <code>T + T = T</code></li>
<li>scalar division <code>T / c = T</code> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4ce0293e41923a7ac472202d45f032e"></a><!-- doxytag: member="cluster::kmedoids::clara" ref="af4ce0293e41923a7ac472202d45f032e" args="(const std::vector&lt; T &gt; &amp;objects, D dmetric, size_t k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clara </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dmetric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CLARA clustering algorithm, as per Kaufman and Rousseuw and R. </p>
<p>Ng and J. Han, "Efficient and Effective Clustering Methods 
        for Spatial Data Mining."</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>Type of objects to be clustered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>D</em>&nbsp;</td><td>Dissimilarity metric type. D should be callable on (T, T) and should return a double.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>objects</em>&nbsp;</td><td>Objects to cluster </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dmetric</em>&nbsp;</td><td>Distance metric to build dissimilarity matrices with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>Number of clusters to partition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae16bab558d4b26b7ab72acf006ac0770"></a><!-- doxytag: member="cluster::kmedoids::cost" ref="ae16bab558d4b26b7ab72acf006ac0770" args="(medoid_id i, object_id h, const dissimilarity_matrix &amp;distance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total cost of swapping object h with medoid i. </p>
<p>Sums costs of this exchagne for all objects j. </p>

</div>
</div>
<a class="anchor" id="ab85094c9fa2a94d0fc0b2ad0a06dd140"></a><!-- doxytag: member="cluster::kmedoids::init_medoids" ref="ab85094c9fa2a94d0fc0b2ad0a06dd140" args="(size_t k, const dissimilarity_matrix &amp;distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_medoids </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>KR BUILD algorithm for assigning initial medoids to a partition. </p>

</div>
</div>
<a class="anchor" id="abb472d7a1325a47b8abde2af0509089c"></a><!-- doxytag: member="cluster::kmedoids::pam" ref="abb472d7a1325a47b8abde2af0509089c" args="(const dissimilarity_matrix &amp;distance, size_t k, const object_id *initial_medoids=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315">object_id</a> *&nbsp;</td>
          <td class="paramname"> <em>initial_medoids</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in Kaufman and Rousseeuw. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>dissimilarity matrix for all objects to cluster </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>number of clusters to produce </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_medoids</em>&nbsp;</td><td>Optionally supply k initial object ids to be used as initial medoids.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacecluster.html#ac42a89b1657078539345f7ff233803cd">build_dissimilarity_matrix()</a>, a function to automatically construct a dissimilarity matrix given a vector of objects and a distance function. </dd></dl>

</div>
</div>
<a class="anchor" id="a419b9d3140b288429149fd13e3b59bf1"></a><!-- doxytag: member="cluster::kmedoids::set_epsilon" ref="a419b9d3140b288429149fd13e3b59bf1" args="(double epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_epsilon </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set tolerance for convergence. </p>
<p>This is relative error, not absolute error. It will be multiplied by the mean distance before it is used to test convergence. Defaults to 1e-15; may need to be higher if there exist clusterings with very similar quality. </p>

</div>
</div>
<a class="anchor" id="a626d40cc1199459d516a63fd8ab314c9"></a><!-- doxytag: member="cluster::kmedoids::set_init_size" ref="a626d40cc1199459d516a63fd8ab314c9" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_init_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb5df16fa21f073c832b6dc0af5a0f5c"></a><!-- doxytag: member="cluster::kmedoids::set_max_reps" ref="aeb5df16fa21f073c832b6dc0af5a0f5c" args="(size_t r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_max_reps </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65c8749d81dc0f963a309b14a226d939"></a><!-- doxytag: member="cluster::kmedoids::set_sort_medoids" ref="a65c8749d81dc0f963a309b14a226d939" args="(bool sort_medoids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_sort_medoids </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sort_medoids</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether medoids will be sorted by object id after clustering is complete. </p>
<p>Defaults to true. </p>

</div>
</div>
<a class="anchor" id="a1d52b3ba9710ea8dca5789326e124411"></a><!-- doxytag: member="cluster::kmedoids::set_xcallback" ref="a1d52b3ba9710ea8dca5789326e124411" args="(void(*)(const partition &amp;part, double bic))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_xcallback </td>
          <td>(</td>
          <td class="paramtype">void(*)(const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;part, double bic)&nbsp;</td>
          <td class="paramname"> <em>xpc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set callback function for XPAM and XCLARA. default is none. </p>

</div>
</div>
<a class="anchor" id="a309f7bb703fec73b13e2582f0ee35521"></a><!-- doxytag: member="cluster::kmedoids::xclara" ref="a309f7bb703fec73b13e2582f0ee35521" args="(const std::vector&lt; T &gt; &amp;objects, D dmetric, size_t max_k, size_t dimensionality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xclara </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>dmetric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dimensionality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>K-Agnostic version of CLARA. </p>
<p>This uses the BIC criterion as described in <a class="el" href="bic_8h.html" title="Template function implementations of the Bayesian Information Criterion.">bic.h</a> to run <a class="el" href="classcluster_1_1kmedoids.html#af4ce0293e41923a7ac472202d45f032e" title="CLARA clustering algorithm, as per Kaufman and Rousseuw and R.">clara()</a> a number of times and to select a best run of <a class="el" href="classcluster_1_1kmedoids.html#af4ce0293e41923a7ac472202d45f032e" title="CLARA clustering algorithm, as per Kaufman and Rousseuw and R.">clara()</a> from the trials. This will be slower than regular <a class="el" href="classcluster_1_1kmedoids.html#af4ce0293e41923a7ac472202d45f032e" title="CLARA clustering algorithm, as per Kaufman and Rousseuw and R.">clara()</a>. In particular, it's O(n*max_k).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>objects</em>&nbsp;</td><td>Objects to cluster </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dmetric</em>&nbsp;</td><td>Distance metric to build dissimilarity matrices with </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_k</em>&nbsp;</td><td>Max number of clusters to find. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimensionality</em>&nbsp;</td><td>Dimensionality of objects, used by BIC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5116cf4e711e642a338d783029fdee3e"></a><!-- doxytag: member="cluster::kmedoids::xpam" ref="a5116cf4e711e642a338d783029fdee3e" args="(const dissimilarity_matrix &amp;distance, size_t max_k, size_t dimensionality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xpam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c">dissimilarity_matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>dimensionality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in Kaufman and Rousseeuw. </p>
<p>Runs PAM from 1 to max_k and selects the best k using the bayesian information criterion. Sets this partition to the best partition found using PAM from 1 to k.</p>
<p>Based on X-Means, see Pelleg &amp; Moore, 2000.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>dissimilarity matrix for all objects to cluster </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_k</em>&nbsp;</td><td>Upper limit on number of clusters to find. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dimensionality</em>&nbsp;</td><td>Number of dimensions in clustered data, for BIC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the best BIC value found (the bic value of the final partitioning).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacecluster.html#ac42a89b1657078539345f7ff233803cd">build_dissimilarity_matrix()</a>, a function to automatically construct a dissimilarity matrix given a vector of objects and a distance function. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4904cc82627458fdf6672ccc0b2802c7"></a><!-- doxytag: member="cluster::kmedoids::epsilon" ref="a4904cc82627458fdf6672ccc0b2802c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcluster_1_1kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7">epsilon</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether medoids should be canonically sorted by object id. </p>

</div>
</div>
<a class="anchor" id="a6aad23523234e617409dbf31687f6876"></a><!-- doxytag: member="cluster::kmedoids::init_size" ref="a6aad23523234e617409dbf31687f6876" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcluster_1_1kmedoids.html#a6aad23523234e617409dbf31687f6876">init_size</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalized sensitivity for convergence. </p>

</div>
</div>
<a class="anchor" id="af4c641bc801fd71d691835566187f4b3"></a><!-- doxytag: member="cluster::kmedoids::max_reps" ref="af4c641bc801fd71d691835566187f4b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcluster_1_1kmedoids.html#af4c641bc801fd71d691835566187f4b3">max_reps</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initial sample size (before 2*k) </p>

</div>
</div>
<a class="anchor" id="a33f9ad5daa74665e7f020f8d4f6b16a8"></a><!-- doxytag: member="cluster::kmedoids::random" ref="a33f9ad5daa74665e7f020f8d4f6b16a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcluster_1_1kmedoids.html#a74d615255c4ed34fb8d88224f645e996">random_type</a> <a class="el" href="classcluster_1_1kmedoids.html#a33f9ad5daa74665e7f020f8d4f6b16a8">random</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type for RNG used in this algorithm. </p>

</div>
</div>
<a class="anchor" id="ad2ffe85547bbc76ec5fd310505929c7a"></a><!-- doxytag: member="cluster::kmedoids::rng" ref="ad2ffe85547bbc76ec5fd310505929c7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcluster_1_1kmedoids.html#abd98da4790855a733e84b4701b1147c8">rng_type</a> <a class="el" href="classcluster_1_1kmedoids.html#ad2ffe85547bbc76ec5fd310505929c7a">rng</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a116dd4dde490d47267f1de54533cee8c"></a><!-- doxytag: member="cluster::kmedoids::sec_nearest" ref="a116dd4dde490d47267f1de54533cee8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacecluster.html#aea622505d1fa9f4641796167e37f1092">medoid_id</a>&gt; <a class="el" href="classcluster_1_1kmedoids.html#a116dd4dde490d47267f1de54533cee8c">sec_nearest</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84f51d7da6fb7899ecf1bcb3174014d2"></a><!-- doxytag: member="cluster::kmedoids::sort_medoids" ref="a84f51d7da6fb7899ecf1bcb3174014d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcluster_1_1kmedoids.html#a84f51d7da6fb7899ecf1bcb3174014d2">sort_medoids</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total dissimilarity bt/w objects and their medoid. </p>

</div>
</div>
<a class="anchor" id="a752062b45d39866c3b974523a888d220"></a><!-- doxytag: member="cluster::kmedoids::total_dissimilarity" ref="a752062b45d39866c3b974523a888d220" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcluster_1_1kmedoids.html#a752062b45d39866c3b974523a888d220">total_dissimilarity</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of second closest medoids. Used by PAM. </p>

</div>
</div>
<a class="anchor" id="aac1f10a7a858e6e198f855a0d24a0a84"></a><!-- doxytag: member="cluster::kmedoids::xcallback" ref="aac1f10a7a858e6e198f855a0d24a0a84" args=")(const partition &amp;part, double bic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="classcluster_1_1kmedoids.html#aac1f10a7a858e6e198f855a0d24a0a84">xcallback</a>)(const <a class="el" href="structcluster_1_1partition.html">partition</a> &amp;part, double bic)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initial sample size (before 2*k) </p>
<p>Callback for each iteration of xpam. is called with the current clustering and its BIC score. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="kmedoids_8h_source.html">kmedoids.h</a></li>
<li>src/<a class="el" href="kmedoids_8cpp.html">kmedoids.cpp</a></li>
</ul>
</div>
<hr class="footer"/>
<a href="http://www.doxygen.org/">
    <img border="0" src="doxygen.png" align="left" style="margin-right:10px;margin-left:5px;"/>
</a>
<small>
<b>Muster</b>.
Copyright &copy; 2010, <a href="http://www.llnl.gov">Lawrence Livermore National Laboratory</a>,  LLNL-CODE-433662.<br>
Distribution of the Muster documentation is subject to terms of the Muster <a href="http://github.com/tgamblin/muster/blob/master/LICENSE">LICENSE</a>.<br>
Generated on Wed Oct 13 2010 using <a href="http://www.doxygen.org/">Doxygen 1.7.1</a>
</small>

