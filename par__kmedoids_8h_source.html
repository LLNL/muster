<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Muster: src/par_kmedoids.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>src/par_kmedoids.h</h1>  </div>
</div>
<div class="contents">
<a href="par__kmedoids_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">// Copyright (c) 2010, Lawrence Livermore National Security, LLC.  </span>
<a name="l00003"></a>00003 <span class="comment">// Produced at the Lawrence Livermore National Laboratory  </span>
<a name="l00004"></a>00004 <span class="comment">// LLNL-CODE-433662</span>
<a name="l00005"></a>00005 <span class="comment">// All rights reserved.  </span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// This file is part of Muster. For details, see http://github.com/tgamblin/muster. </span>
<a name="l00008"></a>00008 <span class="comment">// Please also read the LICENSE file for further information.</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// Redistribution and use in source and binary forms, with or without modification, are</span>
<a name="l00011"></a>00011 <span class="comment">// permitted provided that the following conditions are met:</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">//  * Redistributions of source code must retain the above copyright notice, this list of</span>
<a name="l00014"></a>00014 <span class="comment">//    conditions and the disclaimer below.</span>
<a name="l00015"></a>00015 <span class="comment">//  * Redistributions in binary form must reproduce the above copyright notice, this list of</span>
<a name="l00016"></a>00016 <span class="comment">//    conditions and the disclaimer (as noted below) in the documentation and/or other materials</span>
<a name="l00017"></a>00017 <span class="comment">//    provided with the distribution.</span>
<a name="l00018"></a>00018 <span class="comment">//  * Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse</span>
<a name="l00019"></a>00019 <span class="comment">//    or promote products derived from this software without specific prior written permission.</span>
<a name="l00020"></a>00020 <span class="comment">//</span>
<a name="l00021"></a>00021 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS</span>
<a name="l00022"></a>00022 <span class="comment">// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00023"></a>00023 <span class="comment">// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</span>
<a name="l00024"></a>00024 <span class="comment">// LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE</span>
<a name="l00025"></a>00025 <span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00026"></a>00026 <span class="comment">// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00027"></a>00027 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<a name="l00028"></a>00028 <span class="comment">// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<a name="l00029"></a>00029 <span class="comment">// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00031"></a>00031 <span class="comment"></span><span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">///</span>
<a name="l00033"></a>00033 <span class="comment">/// @file par_kmedoids.h</span>
<a name="l00034"></a>00034 <span class="comment">/// @author Todd Gamblin tgamblin@llnl.gov</span>
<a name="l00035"></a>00035 <span class="comment">/// @brief CAPEK and XCAPEK scalable parallel clustering algorithms.</span>
<a name="l00036"></a>00036 <span class="comment">/// </span>
<a name="l00037"></a>00037 <span class="comment"></span><span class="preprocessor">#ifndef PAR_KMEDOIDS_H</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define PAR_KMEDOIDS_H</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;boost/iterator/permutation_iterator.hpp&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="_timer_8h.html">Timer.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="kmedoids_8h.html" title="Implementations of the classic clustering algorithms PAM and CLARA, from Finding Groups in Data...">kmedoids.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="multi__gather_8h.html" title="Asynchronous, some-to-some gather operation used by parallel clustering algorithms to simultaneously ...">multi_gather.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="trial_8h.html" title="Data structure representing a trial run of a partitioned clustering algorithm.">trial.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="id__pair_8h.html" title="MPI-packable, templated struct for shipping around an MPI-packable object plus the id of the process ...">id_pair.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="par__partition_8h.html" title="Distributed representation of a partitioning of a data set.">par_partition.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="stl__utils_8h.html">stl_utils.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="bic_8h.html" title="Template function implementations of the Bayesian Information Criterion.">bic.h</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="mpi__bindings_8h.html" title="#defines for switching between MPI and PMPI bindings.">mpi_bindings.h</a>&quot;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">namespace </span>cluster {
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">  ///</span>
<a name="l00060"></a>00060 <span class="comment">  /// This class implements the CAPEK and XCAPEK scalable parallel clustering algorithms.</span>
<a name="l00061"></a>00061 <span class="comment">  /// </span>
<a name="l00062"></a>00062 <span class="comment">  /// For more information on these algorithms, see this paper:</span>
<a name="l00063"></a>00063 <span class="comment">  /// @par</span>
<a name="l00064"></a>00064 <span class="comment">  /// Todd Gamblin, Bronis R. de Supinski, Martin Schulz, Rob Fowler, and Daniel A. Reed.</span>
<a name="l00065"></a>00065 <span class="comment">  /// &lt;a href=&quot;http://www.cs.unc.edu/~tgamblin/pubs/scalable-cluster-ics10.pdf&quot;&gt;</span>
<a name="l00066"></a>00066 <span class="comment">  /// &lt;b&gt;Clustering Performance Data Efficiently at Massive Scales&lt;/b&gt;&lt;/a&gt;.</span>
<a name="l00067"></a>00067 <span class="comment">  /// &lt;i&gt;Proceedings of the International Conference on Supercomputing (ICS&#39;10)&lt;/i&gt;,</span>
<a name="l00068"></a>00068 <span class="comment">  /// Tsukuba, Japan, June 1-4, 2010.</span>
<a name="l00069"></a>00069 <span class="comment">  ///</span>
<a name="l00070"></a>00070 <span class="comment">  /// &lt;b&gt;Example usage:&lt;/b&gt;</span>
<a name="l00071"></a>00071 <span class="comment">  /// @code</span>
<a name="l00072"></a>00072 <span class="comment">  /// // This is a theoretical point struct to be clustered.</span>
<a name="l00073"></a>00073 <span class="comment">  /// struct point {</span>
<a name="l00074"></a>00074 <span class="comment">  ///     double x, y;</span>
<a name="l00075"></a>00075 <span class="comment">  /// };</span>
<a name="l00076"></a>00076 <span class="comment">  /// </span>
<a name="l00077"></a>00077 <span class="comment">  /// // Euclidean distance functor to use for clustering.</span>
<a name="l00078"></a>00078 <span class="comment">  /// struct euclidean_distance {</span>
<a name="l00079"></a>00079 <span class="comment">  ///     double operator()(const point&amp; lhs, const point&amp; rhs) {</span>
<a name="l00080"></a>00080 <span class="comment">  ///         double a = lhs.x - rhs.x;</span>
<a name="l00081"></a>00081 <span class="comment">  ///         double b = lhs.y - rhs.y;</span>
<a name="l00082"></a>00082 <span class="comment">  ///         return sqrt(a*a + b*b);</span>
<a name="l00083"></a>00083 <span class="comment">  ///     }</span>
<a name="l00084"></a>00084 <span class="comment">  /// };</span>
<a name="l00085"></a>00085 <span class="comment">  ///</span>
<a name="l00086"></a>00086 <span class="comment">  /// vector&lt;point&gt; points;</span>
<a name="l00087"></a>00087 <span class="comment">  /// // ... Each process puts some local points in the vector ...</span>
<a name="l00088"></a>00088 <span class="comment">  /// </span>
<a name="l00089"></a>00089 <span class="comment">  /// par_kmedoids parkm(MPI_COMM_WORLD);</span>
<a name="l00090"></a>00090 <span class="comment">  /// vector&lt;point&gt; medoids;   // storage for reprsentatives</span>
<a name="l00091"></a>00091 <span class="comment">  /// </span>
<a name="l00092"></a>00092 <span class="comment">  /// // Run xcapek(), finding a max of 20 clusters among the 2d points.</span>
<a name="l00093"></a>00093 <span class="comment">  /// parkm.xcapek(points, euclidean_distance(), 20, 2, &amp;medoids);</span>
<a name="l00094"></a>00094 <span class="comment">  /// @endcode</span>
<a name="l00095"></a>00095 <span class="comment">  /// </span>
<a name="l00096"></a>00096 <span class="comment">  /// After this runs, these members of &lt;code&gt;parkm&lt;/code&gt; are interesting:</span>
<a name="l00097"></a>00097 <span class="comment">  /// - &lt;code&gt;parkm.\link par_partition::cluster_ids cluster_ids\endlink&lt;/code&gt;: </span>
<a name="l00098"></a>00098 <span class="comment">  ///    A vector of cluster ids for the local objects in &lt;code&gt;points&lt;/code&gt; </span>
<a name="l00099"></a>00099 <span class="comment">  /// - &lt;code&gt;parkm.\link par_partition::medoid_ids medoid_ids\endlink&lt;/code&gt;:</span>
<a name="l00100"></a>00100 <span class="comment">  ///    A vector of object ids for all the cluster representatives</span>
<a name="l00101"></a>00101 <span class="comment">  /// </span>
<a name="l00102"></a>00102 <span class="comment">  /// Together, these define the clustering that the algorithm found. See par_partition </span>
<a name="l00103"></a>00103 <span class="comment">  /// for an explanation of how distributed partitions like this are represented.</span>
<a name="l00104"></a>00104 <span class="comment">  /// </span>
<a name="l00105"></a>00105 <span class="comment">  /// The &lt;code&gt;medoids&lt;/code&gt; vector contains actual copies of the representatives for each cluster.</span>
<a name="l00106"></a>00106 <span class="comment">  /// The copies correspond to the object ids in &lt;code&gt;parkm.medoid_ids&lt;/code&gt;.  Supplying</span>
<a name="l00107"></a>00107 <span class="comment">  /// the &lt;code&gt;medoids&lt;/code&gt; vector like this is optional, so if you don&#39;t need copies of</span>
<a name="l00108"></a>00108 <span class="comment">  /// the representatives, you can omit it from the call.</span>
<a name="l00109"></a>00109 <span class="comment">  /// </span>
<a name="l00110"></a>00110 <span class="comment">  /// @endcode</span>
<a name="l00111"></a>00111 <span class="comment">  ///</span>
<a name="l00112"></a><a class="code" href="classcluster_1_1par__kmedoids.html">00112</a> <span class="comment"></span>  <span class="keyword">class </span><a class="code" href="classcluster_1_1par__kmedoids.html" title="This class implements the CAPEK and XCAPEK scalable parallel clustering algorithms.">par_kmedoids</a> : <span class="keyword">public</span> <a class="code" href="structcluster_1_1par__partition.html" title="par_partition represents a partitioning of a distributed data set.">par_partition</a> {
<a name="l00113"></a>00113   <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">    ///</span>
<a name="l00115"></a>00115 <span class="comment">    /// Constructs a parallel kmedoids object and seeds its random number generator.</span>
<a name="l00116"></a>00116 <span class="comment">    /// This is a collective operation, and needs to be called by all processes.</span>
<a name="l00117"></a>00117 <span class="comment">    ///</span>
<a name="l00118"></a>00118 <span class="comment">    /// par_kmedoids assumes that there is one object to be clustered per process.</span>
<a name="l00119"></a>00119 <span class="comment">    ///</span>
<a name="l00120"></a>00120 <span class="comment"></span>    <a class="code" href="classcluster_1_1par__kmedoids.html#a7a44a5ee645ee45cb479d37e3d1c4e31" title="Constructs a parallel kmedoids object and seeds its random number generator.">par_kmedoids</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a> = MPI_COMM_WORLD);
<a name="l00121"></a>00121 
<a name="l00122"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a4a1cd2eabb5bc734250e034d7a658a58">00122</a>     <span class="keyword">virtual</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4a1cd2eabb5bc734250e034d7a658a58">~par_kmedoids</a>() { }
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">    /// Get the average dissimilarity of objects w/their medoids for the last run.</span>
<a name="l00125"></a>00125 <span class="comment"></span>    <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aefdef4bfd3bcbf2e1fd63cf7b3924615" title="Get the average dissimilarity of objects w/their medoids for the last run.">average_dissimilarity</a>();
<a name="l00126"></a>00126 <span class="comment"></span>
<a name="l00127"></a>00127 <span class="comment">    /// BIC score for selected clustering</span>
<a name="l00128"></a>00128 <span class="comment"></span>    <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a78a7d200bc68f11fc75d6a426f96a7da" title="BIC score for selected clustering.">bic_score</a>();
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">    ///</span>
<a name="l00131"></a>00131 <span class="comment">    /// Sets max_reps, Max number of times to run PAM with each sampled dataset.</span>
<a name="l00132"></a>00132 <span class="comment">    /// Default is 5, per Kaufman and Rousseeuw.</span>
<a name="l00133"></a>00133 <span class="comment">    ///</span>
<a name="l00134"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a05e1f5c528ed8d41479b6d81ec7874e4">00134</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a05e1f5c528ed8d41479b6d81ec7874e4" title="Sets max_reps, Max number of times to run PAM with each sampled dataset.">set_max_reps</a>(<span class="keywordtype">size_t</span> reps) { <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a> = reps; }
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">    ///</span>
<a name="l00137"></a>00137 <span class="comment">    /// Max number of times to run PAM with each sampled dataset.</span>
<a name="l00138"></a>00138 <span class="comment">    ///</span>
<a name="l00139"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a08761f65d4e113dfcd70df17a176d853">00139</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a08761f65d4e113dfcd70df17a176d853" title="Max number of times to run PAM with each sampled dataset.">get_max_reps</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>; }
<a name="l00140"></a>00140     <span class="comment"></span>
<a name="l00141"></a>00141 <span class="comment">    ///</span>
<a name="l00142"></a>00142 <span class="comment">    /// Sets init_size, baseline size for samples, added to 2*k.</span>
<a name="l00143"></a>00143 <span class="comment">    /// Defaults to 40, per Kaufman and Rousseeuw.</span>
<a name="l00144"></a>00144 <span class="comment">    ///</span>
<a name="l00145"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a82827f8d32b0003429a4c3c17af6a25e">00145</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a82827f8d32b0003429a4c3c17af6a25e" title="Sets init_size, baseline size for samples, added to 2*k.">set_init_size</a>(<span class="keywordtype">size_t</span> size) { <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a> = size; }
<a name="l00146"></a>00146     <span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">    ///</span>
<a name="l00148"></a>00148 <span class="comment">    /// Baseline size for samples, added to 2*k.</span>
<a name="l00149"></a>00149 <span class="comment">    ///</span>
<a name="l00150"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a31833400b7e60ff1c4cf21a5bcfbc225">00150</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a31833400b7e60ff1c4cf21a5bcfbc225" title="Baseline size for samples, added to 2*k.">get_init_size</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>; }
<a name="l00151"></a>00151 <span class="comment"></span>
<a name="l00152"></a>00152 <span class="comment">    /// Set tolerance for convergence.  This is relative error, not absolute error.  It will be</span>
<a name="l00153"></a>00153 <span class="comment">    /// multiplied by the mean distance before it is used to test convergence.</span>
<a name="l00154"></a>00154 <span class="comment">    /// Defaults to 1e-15; may need to be higher if there exist clusterings with very similar quality.</span>
<a name="l00155"></a>00155 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a419b9d3140b288429149fd13e3b59bf1" title="Set tolerance for convergence.">set_epsilon</a>(<span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">    ///</span>
<a name="l00159"></a>00159 <span class="comment">    /// Farms out trials of PAM to worker processes then collects medoids from all trials to all processors.</span>
<a name="l00160"></a>00160 <span class="comment">    /// Puts resulting medoids in all_medoids when done.</span>
<a name="l00161"></a>00161 <span class="comment">    ///</span>
<a name="l00162"></a>00162 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00163"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7">00163</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(<a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a>&amp; trials, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, 
<a name="l00164"></a>00164                         std::vector&lt;<span class="keyword">typename</span> <a class="code" href="structcluster_1_1id__pair.html#a7377914a95a9724684cca5075f889ea2" title="Template typedef for declaring vectors of id_pair&amp;lt;T&amp;gt;">id_pair&lt;T&gt;::vector</a>&gt;&amp; all_medoids, MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>)
<a name="l00165"></a>00165     {
<a name="l00166"></a>00166       <span class="keywordtype">int</span> size, rank;
<a name="l00167"></a>00167       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(comm, &amp;size);
<a name="l00168"></a>00168       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(comm, &amp;rank);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       <span class="comment">// array for packed medoid arrays from trials -- we&#39;ll broadcast from/to here.</span>
<a name="l00171"></a>00171       std::vector&lt; std::vector&lt;char&gt; &gt; bcast_buffers(all_medoids.size());
<a name="l00172"></a>00172       
<a name="l00173"></a>00173       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; trials.<a class="code" href="classcluster_1_1trial__generator.html#ad3c044665f52e3f3b65f671625a070d4" title="whether there are trials remaining.">has_next</a>(); i++) {
<a name="l00174"></a>00174         <span class="keywordtype">int</span> my_k = -1;                        <span class="comment">// trial id for local run of kmedoids</span>
<a name="l00175"></a>00175         <span class="keywordtype">int</span> my_trial = -1;                    <span class="comment">// trial id for local run of kmedoids</span>
<a name="l00176"></a>00176         std::vector&lt;size_t&gt;  my_ids;          <span class="comment">// object ids for each of my_objects</span>
<a name="l00177"></a>00177         std::vector&lt;T&gt;       my_objects;      <span class="comment">// vector to hold local sample of objects for clustering.</span>
<a name="l00178"></a>00178         <a class="code" href="classcluster_1_1multi__gather.html" title="Asynchronous, some-to-some gather operation used by parallel clustering algorithms to simultaneously ...">multi_gather&lt;T&gt;</a>      <a class="code" href="structcluster_1_1par__partition.html#a02d94b5ae788fc7ac1a397875e8d4533" title="Collective operation.">gather</a>(comm);    <span class="comment">// simultaneous, asynchronous local gathers for collecting samples.</span>
<a name="l00179"></a>00179         
<a name="l00180"></a>00180         <span class="comment">// start gathers for each trial to aggregate samples to single worker processes.</span>
<a name="l00181"></a>00181         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> root=0; trials.<a class="code" href="classcluster_1_1trial__generator.html#ad3c044665f52e3f3b65f671625a070d4" title="whether there are trials remaining.">has_next</a>() &amp;&amp; root &lt; size; root++) {
<a name="l00182"></a>00182           <a class="code" href="structcluster_1_1trial.html" title="This struct represents parameters for a single trial run of kmedoids.">trial</a> cur_trial = trials.<a class="code" href="classcluster_1_1trial__generator.html#a7832cbc625558fb4856d5114581c3a64" title="return parameters for next trial">next</a>();    <span class="comment">// generate a trial descriptor</span>
<a name="l00183"></a>00183           
<a name="l00184"></a>00184           <span class="comment">// Generate a set of indices for members of this k-medoids trial</span>
<a name="l00185"></a>00185           std::vector&lt;size_t&gt; sample_ids;
<a name="l00186"></a>00186           boost::random_number_generator&lt;random_t&gt; rng(<a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2" title="Random number distribution to be used for samples.">random</a>);  <span class="comment">// Boost adaptor for STL RNG&#39;s</span>
<a name="l00187"></a>00187           <a class="code" href="namespacecluster.html#a5a49ac83447a427e107632127220ebc8" title="This is Knuth&amp;#39;s algorithm R for taking a sample of indices from 0 to numElements.">random_subset</a>(trials.<a class="code" href="classcluster_1_1trial__generator.html#a1ec0a2c32feae7df7b105b92b3838806" title="number of elements in the data set; determines maximum sample size.">num_objects</a>, cur_trial.<a class="code" href="structcluster_1_1trial.html#aecbfe89adcb57f51a2c4370c50acedbb">sample_size</a>, std::back_inserter(sample_ids), rng);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189           <span class="comment">// figure out where the sample objects live, ASSUME objects.size() objs per process.</span>
<a name="l00190"></a>00190           std::vector&lt;int&gt; sources;
<a name="l00191"></a>00191           std::transform(sample_ids.begin(), sample_ids.end(), std::back_inserter(sources),
<a name="l00192"></a>00192                          std::bind2nd(std::divides&lt;size_t&gt;(), objects.size()));
<a name="l00193"></a>00193           sources.erase(std::unique(sources.begin(), sources.end()), sources.end());
<a name="l00194"></a>00194 
<a name="l00195"></a>00195           <span class="comment">// make a permutation vector for the indices of the sampled *local* objects</span>
<a name="l00196"></a>00196           std::vector&lt;size_t&gt; sample_indices;
<a name="l00197"></a>00197           transform(std::lower_bound(sample_ids.begin(), sample_ids.end(), objects.size() * rank),
<a name="l00198"></a>00198                     std::lower_bound(sample_ids.begin(), sample_ids.end(), objects.size() * (rank + 1)),
<a name="l00199"></a>00199                     std::back_inserter(sample_indices),
<a name="l00200"></a>00200                     std::bind2nd(std::minus&lt;int&gt;(), objects.size() * rank));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202           <span class="comment">// gather trial members to the current worker (root)</span>
<a name="l00203"></a>00203           gather.<a class="code" href="classcluster_1_1multi__gather.html#a24d640a945fc8cf40db8c4135025a0d4" title="Starts initial send and receive requests for this gather.">start</a>(boost::make_permutation_iterator(objects.begin(), sample_indices.begin()), 
<a name="l00204"></a>00204                        boost::make_permutation_iterator(objects.begin(), sample_indices.end()),
<a name="l00205"></a>00205                        sources.begin(), sources.end(), my_objects, root);
<a name="l00206"></a>00206           
<a name="l00207"></a>00207           <span class="comment">// record which trial to use locally and save the medoids there.</span>
<a name="l00208"></a>00208           <span class="keywordflow">if</span> (rank == root) {
<a name="l00209"></a>00209             my_k     = cur_trial.<a class="code" href="structcluster_1_1trial.html#a9389e4770ba454a2e14f870491495cb2">k</a>;
<a name="l00210"></a>00210             my_trial = trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>() - 1;
<a name="l00211"></a>00211             my_ids.swap(sample_ids);
<a name="l00212"></a>00212           }
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;StartGather&quot;</span>);
<a name="l00215"></a>00215         
<a name="l00216"></a>00216         <span class="comment">// finish all sample gathers.</span>
<a name="l00217"></a>00217         gather.<a class="code" href="classcluster_1_1multi__gather.html#a6dfe1abe0d1eb3ddc1ca081de98b5342">finish</a>();
<a name="l00218"></a>00218         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;FinishGather&quot;</span>);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="comment">// if we&#39;re a worker process (we were assigned a trial number) then run PAM on the sample.</span>
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (my_trial &gt;= 0) {
<a name="l00222"></a>00222           <a class="code" href="classcluster_1_1kmedoids.html" title="Implementations of the classic clustering algorithms PAM and CLARA, from Finding Groups in Data...">kmedoids</a> cluster;
<a name="l00223"></a>00223           cluster.<a class="code" href="classcluster_1_1kmedoids.html#a419b9d3140b288429149fd13e3b59bf1" title="Set tolerance for convergence.">set_epsilon</a>(<a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225           <a class="code" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c" title="Packed repersentation of symmetric dissimilarity matrix.">dissimilarity_matrix</a> mat;
<a name="l00226"></a>00226           <a class="code" href="namespacecluster.html#ac42a89b1657078539345f7ff233803cd" title="Computes a dissimilarity matrix from a vector of objects.">build_dissimilarity_matrix</a>(my_objects, dmetric, mat);
<a name="l00227"></a>00227           cluster.<a class="code" href="classcluster_1_1kmedoids.html#abb472d7a1325a47b8abde2af0509089c" title="Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in K...">pam</a>(mat, my_k);
<a name="l00228"></a>00228           <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;LocalCluster&quot;</span>);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230           <span class="comment">// put this trial&#39;s medoids into their spot in the global medoids array.</span>
<a name="l00231"></a>00231           <span class="comment">// and pack them up so that we can bcast them to other processes.</span>
<a name="l00232"></a>00232           <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>.size(); m++) {
<a name="l00233"></a>00233             all_medoids[my_trial].push_back(
<a name="l00234"></a>00234               <a class="code" href="namespacecluster.html#a3e7c255cedb29a255f3907f9037d182a" title="Helper function for making arbitrary id_pairs with type inference.">make_id_pair</a>(my_objects[cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>[m]], my_ids[cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>[m]]));
<a name="l00235"></a>00235           }
<a name="l00236"></a>00236           <a class="code" href="classcluster_1_1par__kmedoids.html#adfe4f3a6622da4038d7f176722a936b4" title="This packs a vector of packable objects on one process.">pack_vector</a>(comm, all_medoids[my_trial], bcast_buffers[my_trial]);
<a name="l00237"></a>00237           <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;PackForBroadcast&quot;</span>);
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240         <span class="comment">// once workers are done clustering, broadcast the medoids from each clustering </span>
<a name="l00241"></a>00241         <span class="comment">// so that all processes have the full all_medoids array.</span>
<a name="l00242"></a>00242         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> trial_id = i * size; trial_id &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); trial_id++) {
<a name="l00243"></a>00243           <span class="keywordtype">int</span> root = trial_id % size;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245           <span class="comment">// broadcast size and allocate receive buffer where needed</span>
<a name="l00246"></a>00246           <span class="keywordtype">size_t</span> packed_size = bcast_buffers[trial_id].size();
<a name="l00247"></a>00247           <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;packed_size, 1, <a class="code" href="mpi__utils_8h.html#aaae430420e25984e327a89b068e1582b">MPI_SIZE_T</a>, root, comm);
<a name="l00248"></a>00248           bcast_buffers[trial_id].resize(packed_size);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250           <span class="comment">// broadcast packed data</span>
<a name="l00251"></a>00251           <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;bcast_buffers[trial_id][0], packed_size, MPI_PACKED, root, comm);
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;Broadcast&quot;</span>);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         <span class="comment">// now once we&#39;re done with the broadcasts, unpack all the data</span>
<a name="l00256"></a>00256         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> trial_id = i * size; trial_id &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); trial_id++) {
<a name="l00257"></a>00257           <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)my_trial != trial_id) {
<a name="l00258"></a>00258             <a class="code" href="classcluster_1_1par__kmedoids.html#a8bdeb4c589deb473105175b36bebd6fe" title="This unpacks a vector of packable objects packed by pack_vector().">unpack_vector</a>(comm, bcast_buffers[trial_id], all_medoids[trial_id]);
<a name="l00259"></a>00259           }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261           <span class="comment">// save some space: no longer need packed data here.</span>
<a name="l00262"></a>00262           bcast_buffers[trial_id].clear();
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;UnpackFromBroadcast&quot;</span>);
<a name="l00265"></a>00265       }
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267 <span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">    ///</span>
<a name="l00269"></a>00269 <span class="comment">    /// This is the Clustering Algorithm with Parallel Extensions to K-Medoids (CAPEK).</span>
<a name="l00270"></a>00270 <span class="comment">    /// </span>
<a name="l00271"></a>00271 <span class="comment">    /// Assumes that objects to be clustered are fully distributed across parallel process, </span>
<a name="l00272"></a>00272 <span class="comment">    /// with the same number of objects per process.  </span>
<a name="l00273"></a>00273 <span class="comment">    ///</span>
<a name="l00274"></a>00274 <span class="comment">    /// @tparam T     Type of objects to be clustered.</span>
<a name="l00275"></a>00275 <span class="comment">    ///               T must support the following operations:</span>
<a name="l00276"></a>00276 <span class="comment">    ///               - &lt;code&gt;int packed_size(MPI_Comm comm) const&lt;/code&gt;</span>
<a name="l00277"></a>00277 <span class="comment">    ///               - &lt;code&gt;void pack(void *buf, int bufsize, int *position, MPI_Comm comm) const&lt;/code&gt;</span>
<a name="l00278"></a>00278 <span class="comment">    ///               - &lt;code&gt;static T unpack(void *buf, int bufsize, int *position, MPI_Comm comm)&lt;/code&gt;</span>
<a name="l00279"></a>00279 <span class="comment">    /// @tparam D     Dissimilarity metric type.  </span>
<a name="l00280"></a>00280 <span class="comment">    ///               D should be callable on (T, T) and should return a double representing </span>
<a name="l00281"></a>00281 <span class="comment">    ///               the distance between the two T&#39;s.</span>
<a name="l00282"></a>00282 <span class="comment">    /// </span>
<a name="l00283"></a>00283 <span class="comment">    /// @param[in]  objects   Local objects to cluster (ASSUME: currently must be same number per process!)</span>
<a name="l00284"></a>00284 <span class="comment">    /// @param[in]  dmetric   Distance metric to build dissimilarity matrices with</span>
<a name="l00285"></a>00285 <span class="comment">    /// @param[in]  k         Number of clusters to find.</span>
<a name="l00286"></a>00286 <span class="comment">    /// @param[out] medoids   Optional output vector where global medoids will </span>
<a name="l00287"></a>00287 <span class="comment">    ///                       be stored along with their source ranks.</span>
<a name="l00288"></a>00288 <span class="comment">    ///</span>
<a name="l00289"></a>00289 <span class="comment">    /// CAPEK will run trials insatances of PAM on separate processors for each k in 1..max_k using the</span>
<a name="l00290"></a>00290 <span class="comment">    /// run_pam_trials() routine. Each trial aggregates sample_size objects distributed over all </span>
<a name="l00291"></a>00291 <span class="comment">    /// processes in the system.</span>
<a name="l00292"></a>00292 <span class="comment">    ///</span>
<a name="l00293"></a>00293 <span class="comment">    /// @see xcapek() for a K-agnostic version of this algorithm.</span>
<a name="l00294"></a>00294 <span class="comment">    ///</span>
<a name="l00295"></a>00295 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00296"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a9e6466011d78034865dfcb0b15e33bf2">00296</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a9e6466011d78034865dfcb0b15e33bf2" title="This is the Clustering Algorithm with Parallel Extensions to K-Medoids (CAPEK).">capek</a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, <span class="keywordtype">size_t</span> k, std::vector&lt;T&gt; *medoids = NULL) 
<a name="l00297"></a>00297     {
<a name="l00298"></a>00298       <span class="keywordtype">int</span> size, rank;
<a name="l00299"></a>00299       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;size);
<a name="l00300"></a>00300       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;rank);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>); <span class="comment">// seed RN generator uniformly across ranks.</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304       <span class="comment">// fix things if k is greater than the number of elements, since we can&#39;t </span>
<a name="l00305"></a>00305       <span class="comment">// ever find that many clusters.</span>
<a name="l00306"></a>00306       <span class="keywordtype">size_t</span> num_objects = size * objects.size();
<a name="l00307"></a>00307       k = std::min(num_objects, k);
<a name="l00308"></a>00308       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;Init&quot;</span>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310       <span class="comment">// do parallel work: farms out trials and broadcasts medoids from each trial to</span>
<a name="l00311"></a>00311       <span class="comment">// all processes.  On completion, medoids from all trials are in all_medoids vector.</span>
<a name="l00312"></a>00312       std::vector&lt;typename id_pair&lt;T&gt;::vector&gt; all_medoids(<a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>);
<a name="l00313"></a>00313       <a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a> trials(k, k, <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>, <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>, num_objects);
<a name="l00314"></a>00314       <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(trials, objects, dmetric, all_medoids, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316       <span class="comment">// Make two arrays to hold our closest medoids and their distance from our object</span>
<a name="l00317"></a>00317       std::vector&lt;double&gt; all_dissimilarities(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), 0.0);           <span class="comment">// dissimilarity sums</span>
<a name="l00318"></a>00318       std::vector&lt; std::vector&lt;medoid_id&gt; &gt; all_cluster_ids(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());  <span class="comment">// local nearest medoid ids</span>
<a name="l00319"></a>00319 
<a name="l00320"></a>00320       <span class="comment">// Go through all the trials again, and for each of them, find the closest </span>
<a name="l00321"></a>00321       <span class="comment">// medoid to this process&#39;s objects and sum the dissimilarities</span>
<a name="l00322"></a>00322       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00323"></a>00323         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> o=0; o &lt; objects.size(); o++) {
<a name="l00324"></a>00324           <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> global_oid = rank + o;
<a name="l00325"></a>00325           std::pair&lt;double, size_t&gt; closest = <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(objects[o], global_oid, all_medoids[i], dmetric);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327           all_dissimilarities[i]  += closest.first;
<a name="l00328"></a>00328           all_cluster_ids[i].push_back(closest.second);
<a name="l00329"></a>00329         }
<a name="l00330"></a>00330       }
<a name="l00331"></a>00331       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;FindMinima&quot;</span>);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333       <span class="comment">// Sum up all the min dissimilarities.  We do a Reduce/Bcast instead of an Allreduce</span>
<a name="l00334"></a>00334       <span class="comment">// to avoid FP error and guarantee that sums is the same across all processors.</span>
<a name="l00335"></a>00335       std::vector&lt;double&gt; sums(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());         <span class="comment">// destination vectors for reduction.</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissimilarities[0],  &amp;sums[0], trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00338"></a>00338       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums[0],  trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00339"></a>00339       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;GlobalSums&quot;</span>);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341       <span class="comment">// find minmum global dissimilarity among all trials.</span>
<a name="l00342"></a>00342       std::vector&lt;double&gt;::iterator min_sum = std::min_element(sums.begin(), sums.end());
<a name="l00343"></a>00343       <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a> = *min_sum;
<a name="l00344"></a>00344       <span class="keywordtype">size_t</span> best = (min_sum - sums.begin());  <span class="comment">// index of best trial.</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347       <span class="comment">// Finally set up the partition to correspond to trial with best dissimilarity found</span>
<a name="l00348"></a>00348       <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.resize(all_medoids[best].size());
<a name="l00349"></a>00349       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00350"></a>00350         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][i].id;
<a name="l00351"></a>00351       }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353       <span class="comment">// Make an indirection vector from the unsorted to sorted medoids</span>
<a name="l00354"></a>00354       std::vector&lt;size_t&gt; mapping(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00355"></a>00355       std::generate(mapping.begin(), mapping.end(), <a class="code" href="structsequence.html" title="Generator object for a strided sequence of ints.">sequence</a>());
<a name="l00356"></a>00356       std::sort(mapping.begin(), mapping.end(), <a class="code" href="stl__utils_8h.html#a3a41193f3a91c6742cda29b111db47d3">indexed_lt</a>(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>));
<a name="l00357"></a>00357       <a class="code" href="stl__utils_8h.html#a0644b99022be056affc7f2c5add448ad">invert</a>(mapping);
<a name="l00358"></a>00358 
<a name="l00359"></a>00359       <span class="comment">// set up local cluster ids, medoids, and medoid_ids with the sorted mapping.</span>
<a name="l00360"></a>00360       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00361"></a>00361         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][mapping[i]].id;
<a name="l00362"></a>00362       }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364       <span class="comment">// swap in the cluster ids with the best BIC score.</span>
<a name="l00365"></a>00365       <a class="code" href="structcluster_1_1par__partition.html#afd520c040af2b60ff8950a86fcc370f9" title="Global cluster ids for local objects.">cluster_ids</a>.swap(all_cluster_ids[best]);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367       <span class="comment">// if the caller wanted a copy of the medoids, copy them into the dstination array.</span>
<a name="l00368"></a>00368       <span class="keywordflow">if</span> (medoids) {
<a name="l00369"></a>00369         medoids-&gt;resize(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00370"></a>00370         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00371"></a>00371           (*medoids)[i] = all_medoids[best][mapping[i]].element;
<a name="l00372"></a>00372         }
<a name="l00373"></a>00373       }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;BicScore&quot;</span>);
<a name="l00376"></a>00376     }    
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="comment"></span>
<a name="l00379"></a>00379 <span class="comment">    ///</span>
<a name="l00380"></a>00380 <span class="comment">    /// K-agnostic version of capek().</span>
<a name="l00381"></a>00381 <span class="comment">    /// This version attempts to guess the best K for the data using the </span>
<a name="l00382"></a>00382 <span class="comment">    /// Bayesian Information Criterion (BIC) described in bic.h.  Evaluation of the </span>
<a name="l00383"></a>00383 <span class="comment">    /// BIC is parallelized using global reduction operations.</span>
<a name="l00384"></a>00384 <span class="comment">    /// </span>
<a name="l00385"></a>00385 <span class="comment">    /// Like capek(), this uses run_pam_trials() to farm out trials of the PAM clustering algorithm,</span>
<a name="l00386"></a>00386 <span class="comment">    /// but it requires more trials than capek().  In particular, it will run </span>
<a name="l00387"></a>00387 <span class="comment">    /// (sum(1..max_k) * trials) total trials in parallel on MPI worker processes.</span>
<a name="l00388"></a>00388 <span class="comment">    ///</span>
<a name="l00389"></a>00389 <span class="comment">    /// @tparam T     Type of objects to be clustered.</span>
<a name="l00390"></a>00390 <span class="comment">    ///               T must support the following operations:</span>
<a name="l00391"></a>00391 <span class="comment">    ///                - &lt;code&gt;int packed_size(MPI_Comm comm) const&lt;/code&gt;</span>
<a name="l00392"></a>00392 <span class="comment">    ///                - &lt;code&gt;void pack(void *buf, int bufsize, int *position, MPI_Comm comm) const&lt;/code&gt;</span>
<a name="l00393"></a>00393 <span class="comment">    ///                - &lt;code&gt;static T unpack(void *buf, int bufsize, int *position, MPI_Comm comm)&lt;/code&gt;</span>
<a name="l00394"></a>00394 <span class="comment">    /// @tparam D     Dissimilarity metric type.  </span>
<a name="l00395"></a>00395 <span class="comment">    ///               D should be callable on (T, T) and should return a double representing </span>
<a name="l00396"></a>00396 <span class="comment">    ///               the distance between the two T&#39;s.</span>
<a name="l00397"></a>00397 <span class="comment">    /// </span>
<a name="l00398"></a>00398 <span class="comment">    /// @param[in]  objects         Local objects to cluster (ASSUME: currently must be same number per process!)</span>
<a name="l00399"></a>00399 <span class="comment">    /// @param[in]  dmetric         Distance metric to build dissimilarity matrices with</span>
<a name="l00400"></a>00400 <span class="comment">    /// @param[in]  max_k           Max number of clusters to find.</span>
<a name="l00401"></a>00401 <span class="comment">    /// @param[in]  dimensionality  Dimensionality of objects, used by BIC.</span>
<a name="l00402"></a>00402 <span class="comment">    /// @param[out] medoids         Optional output vector where global medoids will be stored </span>
<a name="l00403"></a>00403 <span class="comment">    ///                             along with their source ranks.</span>
<a name="l00404"></a>00404 <span class="comment">    ///</span>
<a name="l00405"></a>00405 <span class="comment">    /// @return</span>
<a name="l00406"></a>00406 <span class="comment">    /// The best BIC value found, that is, the BIC value of the final clustering.</span>
<a name="l00407"></a>00407 <span class="comment">    ///</span>
<a name="l00408"></a>00408 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00409"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a6d10b9b98495838ee9425932c6529855">00409</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6d10b9b98495838ee9425932c6529855" title="K-agnostic version of capek().">xcapek</a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, <span class="keywordtype">size_t</span> max_k, <span class="keywordtype">size_t</span> dimensionality,
<a name="l00410"></a>00410                   std::vector&lt;T&gt; *medoids = NULL) 
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412       <span class="keywordtype">int</span> size, rank;
<a name="l00413"></a>00413       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;size);
<a name="l00414"></a>00414       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;rank);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416       <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>); <span class="comment">// seed RN generator uniformly across ranks.</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418       <span class="comment">// fix things if k is greater than the number of elements, since we can&#39;t </span>
<a name="l00419"></a>00419       <span class="comment">// ever find that many clusters.</span>
<a name="l00420"></a>00420       <span class="keywordtype">size_t</span> num_objects = size * objects.size();
<a name="l00421"></a>00421       max_k = std::min(num_objects, max_k);
<a name="l00422"></a>00422       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;Init&quot;</span>);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424       std::vector&lt;typename id_pair&lt;T&gt;::vector&gt; all_medoids(max_k * <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>);
<a name="l00425"></a>00425       <a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a> trials(max_k, max_reps, <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>, num_objects);
<a name="l00426"></a>00426       <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(trials, objects, dmetric, all_medoids, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       <span class="comment">// Make two arrays to hold our closest medoids and their distance from our object</span>
<a name="l00429"></a>00429       std::vector&lt;double&gt; all_dissimilarities(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), 0.0);           <span class="comment">// dissimilarity sums</span>
<a name="l00430"></a>00430       std::vector&lt; std::vector&lt;medoid_id&gt; &gt; all_cluster_ids(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());  <span class="comment">// local nearest medoid ids</span>
<a name="l00431"></a>00431 
<a name="l00432"></a>00432       std::vector&lt;double&gt; all_dissim2;      <span class="comment">// dissimilarity sums squared</span>
<a name="l00433"></a>00433       std::vector&lt;size_t&gt; cluster_sizes;    <span class="comment">// sizes of clusters in each trial</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       <span class="comment">// Go through all the trials again, and for each of them, find the closest </span>
<a name="l00436"></a>00436       <span class="comment">// medoid to this process&#39;s objects and sum the squared dissimilarities</span>
<a name="l00437"></a>00437       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00438"></a>00438         <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_medoids = all_medoids[i].size();
<a name="l00439"></a>00439         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; num_medoids; m++) {
<a name="l00440"></a>00440           all_dissim2.push_back(0.0);
<a name="l00441"></a>00441           cluster_sizes.push_back(0);
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443         <span class="keywordtype">double</span> *dissim2 = &amp;all_dissim2[all_dissim2.size() - num_medoids];
<a name="l00444"></a>00444         <span class="keywordtype">size_t</span> *sizes   = &amp;cluster_sizes[cluster_sizes.size() - num_medoids];
<a name="l00445"></a>00445         
<a name="l00446"></a>00446         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> o=0; o &lt; objects.size(); o++) {
<a name="l00447"></a>00447           <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> global_oid = rank + o;
<a name="l00448"></a>00448           std::pair&lt;double, size_t&gt; closest = <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(objects[o], global_oid, all_medoids[i], dmetric);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450           all_dissimilarities[i]  += closest.first;
<a name="l00451"></a>00451           dissim2[closest.second] += closest.first * closest.first;
<a name="l00452"></a>00452           sizes[closest.second]   += 1;
<a name="l00453"></a>00453           all_cluster_ids[i].push_back(closest.second);
<a name="l00454"></a>00454         }
<a name="l00455"></a>00455       }
<a name="l00456"></a>00456       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;FindMinima&quot;</span>);
<a name="l00457"></a>00457       
<a name="l00458"></a>00458 
<a name="l00459"></a>00459       <span class="comment">// Sum up all the min dissimilarities.  We do a Reduce/Bcast instead of an Allreduce</span>
<a name="l00460"></a>00460       <span class="comment">// to avoid FP error and guarantee that sums is the same across all processors.</span>
<a name="l00461"></a>00461       std::vector&lt;double&gt; sums(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());         <span class="comment">// destination vectors for reduction.</span>
<a name="l00462"></a>00462       std::vector&lt;double&gt; sums2(all_dissim2.size());
<a name="l00463"></a>00463       std::vector&lt;size_t&gt; sizes(cluster_sizes.size());
<a name="l00464"></a>00464 
<a name="l00465"></a>00465       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissimilarities[0],  &amp;sums[0], trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00466"></a>00466       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissim2[0], &amp;sums2[0], sums2.size(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00467"></a>00467       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums[0],  trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00468"></a>00468       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums2[0], sums2.size(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00469"></a>00469       <a class="code" href="mpi__bindings_8h.html#a268656dc03a973bb2f30567f65010984">CMPI_Allreduce</a>(&amp;cluster_sizes[0], &amp;sizes[0], sizes.size(), <a class="code" href="mpi__utils_8h.html#aaae430420e25984e327a89b068e1582b">MPI_SIZE_T</a>, MPI_SUM, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00470"></a>00470       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;GlobalSums&quot;</span>);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472       <span class="comment">// find minmum global dissimilarity among all trials.</span>
<a name="l00473"></a>00473       std::vector&lt;double&gt;::iterator min_sum = std::min_element(sums.begin(), sums.end());
<a name="l00474"></a>00474       <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a> = *min_sum;
<a name="l00475"></a>00475       <span class="keywordtype">size_t</span> best = (min_sum - sums.begin());  <span class="comment">// index of best trial.</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477       <span class="comment">// locally calculate the BIC for each trial</span>
<a name="l00478"></a>00478       <span class="keywordtype">size_t</span> best_trial = 0;
<a name="l00479"></a>00479       <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>    = -DBL_MAX;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481       <span class="keywordtype">size_t</span> trial_offset = 0;  <span class="comment">// offset into sizes array</span>
<a name="l00482"></a>00482       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00483"></a>00483         <span class="keywordtype">size_t</span> k = all_medoids[i].size();
<a name="l00484"></a>00484         <span class="keywordtype">double</span> cur_bic = <a class="code" href="namespacecluster.html#af654c630dfe169d9f005f16956ed293f" title="Directly computes the BIC from a partition object based on the cluster centroids and the number of cl...">bic</a>(k, &amp;sizes[trial_offset], &amp;sums2[trial_offset], dimensionality);
<a name="l00485"></a>00485         <span class="keywordflow">if</span> (cur_bic &gt; <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>) {
<a name="l00486"></a>00486           best_trial     = i;
<a name="l00487"></a>00487           <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a> = cur_bic;
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489         trial_offset += k;
<a name="l00490"></a>00490       }
<a name="l00491"></a>00491       
<a name="l00492"></a>00492       best = best_trial;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494       <span class="comment">// Finally set up the partition to correspond to best trial found.</span>
<a name="l00495"></a>00495       <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.resize(all_medoids[best].size());
<a name="l00496"></a>00496       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00497"></a>00497         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][i].id;
<a name="l00498"></a>00498       }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500       <span class="comment">// Make an indirection vector from the unsorted to sorted medoids.</span>
<a name="l00501"></a>00501       std::vector&lt;size_t&gt; mapping(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00502"></a>00502       std::generate(mapping.begin(), mapping.end(), <a class="code" href="structsequence.html" title="Generator object for a strided sequence of ints.">sequence</a>());
<a name="l00503"></a>00503       std::sort(mapping.begin(), mapping.end(), <a class="code" href="stl__utils_8h.html#a3a41193f3a91c6742cda29b111db47d3">indexed_lt</a>(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>));
<a name="l00504"></a>00504       <a class="code" href="stl__utils_8h.html#a0644b99022be056affc7f2c5add448ad">invert</a>(mapping);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506       <span class="comment">// set up local cluster ids, medoids, and medoid_ids with the sorted mapping.</span>
<a name="l00507"></a>00507       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00508"></a>00508         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][mapping[i]].id;
<a name="l00509"></a>00509       }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511       <span class="comment">// swap in the cluster ids with the best BIC score.</span>
<a name="l00512"></a>00512       <a class="code" href="structcluster_1_1par__partition.html#afd520c040af2b60ff8950a86fcc370f9" title="Global cluster ids for local objects.">cluster_ids</a>.swap(all_cluster_ids[best]);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514       <span class="comment">// if the user wanted a copy of the medoids, copy them into the dstination array.</span>
<a name="l00515"></a>00515       <span class="keywordflow">if</span> (medoids) {
<a name="l00516"></a>00516         medoids-&gt;resize(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00517"></a>00517         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00518"></a>00518           (*medoids)[i] = all_medoids[best][mapping[i]].element;
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520       }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.<a class="code" href="class_timer.html#ab7ee5a7b052c712eefb9a08243628119" title="Records time since start or last call to record.">record</a>(<span class="stringliteral">&quot;BicScore&quot;</span>);
<a name="l00523"></a>00523       <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>;
<a name="l00524"></a>00524     }    
<a name="l00525"></a>00525     <span class="comment"></span>
<a name="l00526"></a>00526 <span class="comment">    /// Get the Timer with info on the last run of either capek() or xcapek().</span>
<a name="l00527"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a41466ea324bfff7bec48d504692e135b">00527</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="class_timer.html">Timer</a>&amp; <a class="code" href="classcluster_1_1par__kmedoids.html#a41466ea324bfff7bec48d504692e135b" title="Get the Timer with info on the last run of either capek() or xcapek().">get_timer</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>; }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529   <span class="keyword">protected</span>:
<a name="l00530"></a><a class="code" href="classcluster_1_1par__kmedoids.html#ac5c6013aecf88eb9e9a3011a2158f867">00530</a>     <span class="keyword">typedef</span> boost::mt19937 <a class="code" href="classcluster_1_1par__kmedoids.html#ac5c6013aecf88eb9e9a3011a2158f867" title="Type for random number generator used here.">random_t</a>;   <span class="comment">///&lt; Type for random number generator used here.</span>
<a name="l00531"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2">00531</a> <span class="comment"></span>    <a class="code" href="classcluster_1_1par__kmedoids.html#ac5c6013aecf88eb9e9a3011a2158f867" title="Type for random number generator used here.">random_t</a> <a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2" title="Random number distribution to be used for samples.">random</a>;                   <span class="comment">///&lt; Random number distribution to be used for samples</span>
<a name="l00532"></a>00532 <span class="comment"></span>    
<a name="l00533"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220">00533</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a>;   <span class="comment">///&lt; Total dissimilarity bt/w objects and medoids for last clustering.</span>
<a name="l00534"></a><a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74">00534</a> <span class="comment"></span>    <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>;        <span class="comment">///&lt; BIC score for the clustering found.</span>
<a name="l00535"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876">00535</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>;             <span class="comment">///&lt; baseline size for samples</span>
<a name="l00536"></a><a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3">00536</a> <span class="comment"></span>    <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>;              <span class="comment">///&lt; Max repetitions of trials for a particular k.</span>
<a name="l00537"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7">00537</a> <span class="comment"></span>    <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>;               <span class="comment">///&lt; Tolerance for convergence tests in kmedoids PAM runs.</span>
<a name="l00538"></a>00538 <span class="comment"></span>
<a name="l00539"></a><a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4">00539</a>     <a class="code" href="class_timer.html">Timer</a> <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>;                  <span class="comment">///&lt; Performance timer.</span>
<a name="l00540"></a>00540 <span class="comment"></span><span class="comment"></span>
<a name="l00541"></a>00541 <span class="comment">    /// </span>
<a name="l00542"></a>00542 <span class="comment">    /// Seeds random number generators across all processes with the same number,</span>
<a name="l00543"></a>00543 <span class="comment">    /// taken from the time in microseconds since the epoch on the process 0.</span>
<a name="l00544"></a>00544 <span class="comment">    /// </span>
<a name="l00545"></a>00545 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">    ///</span>
<a name="l00548"></a>00548 <span class="comment">    /// This packs a vector of packable objects on one process.</span>
<a name="l00549"></a>00549 <span class="comment">    /// To be packable, T must support these operations:</span>
<a name="l00550"></a>00550 <span class="comment">    ///    - int packed_size(MPI_Comm comm) const</span>
<a name="l00551"></a>00551 <span class="comment">    ///    - void pack(void *buf, int bufsize, int *position, MPI_Comm comm) const</span>
<a name="l00552"></a>00552 <span class="comment">    ///    - static T unpack(void *buf, int bufsize, int *position, MPI_Comm comm)</span>
<a name="l00553"></a>00553 <span class="comment">    /// Each T in the input vector is packed and put on the back of </span>
<a name="l00554"></a>00554 <span class="comment">    ///</span>
<a name="l00555"></a>00555 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00556"></a><a class="code" href="classcluster_1_1par__kmedoids.html#adfe4f3a6622da4038d7f176722a936b4">00556</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#adfe4f3a6622da4038d7f176722a936b4" title="This packs a vector of packable objects on one process.">pack_vector</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; packables, std::vector&lt;char&gt;&amp; buffer) {
<a name="l00557"></a>00557       <span class="comment">// figure out size of packed buffer</span>
<a name="l00558"></a>00558       <span class="keywordtype">int</span> packed_size = 0;
<a name="l00559"></a>00559       packed_size += <a class="code" href="mpi__bindings_8h.html#a19f4c652252a22e96d5238908f6cb6d4">cmpi_packed_size</a>(1, <a class="code" href="mpi__utils_8h.html#aaae430420e25984e327a89b068e1582b">MPI_SIZE_T</a>, comm);  <span class="comment">// num packables for trial.</span>
<a name="l00560"></a>00560       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; packables.size(); i++) {          <span class="comment">// size of packables.</span>
<a name="l00561"></a>00561         packed_size += packables[i].packed_size(comm);
<a name="l00562"></a>00562       }
<a name="l00563"></a>00563       buffer.resize(packed_size);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565       <span class="comment">// pack buffer with medoid objects</span>
<a name="l00566"></a>00566       <span class="keywordtype">int</span> pos = 0;
<a name="l00567"></a>00567       <span class="keywordtype">size_t</span> num_packables = packables.size();
<a name="l00568"></a>00568       <a class="code" href="mpi__bindings_8h.html#abc3639efb607f9c5918a5a79765d389c">CMPI_Pack</a>(&amp;num_packables, 1, <a class="code" href="mpi__utils_8h.html#aaae430420e25984e327a89b068e1582b">MPI_SIZE_T</a>, &amp;buffer[0], packed_size, &amp;pos, comm);
<a name="l00569"></a>00569       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; num_packables; i++) {
<a name="l00570"></a>00570         packables[i].pack(&amp;buffer[0], packed_size, &amp;pos, comm);
<a name="l00571"></a>00571       }
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573 <span class="comment"></span>
<a name="l00574"></a>00574 <span class="comment">    ///</span>
<a name="l00575"></a>00575 <span class="comment">    /// This unpacks a vector of packable objects packed by pack_vector().</span>
<a name="l00576"></a>00576 <span class="comment">    ///</span>
<a name="l00577"></a>00577 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00578"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a8bdeb4c589deb473105175b36bebd6fe">00578</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a8bdeb4c589deb473105175b36bebd6fe" title="This unpacks a vector of packable objects packed by pack_vector().">unpack_vector</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, <span class="keyword">const</span> std::vector&lt;char&gt;&amp; buffer, std::vector&lt;T&gt;&amp; packables) {
<a name="l00579"></a>00579       <span class="keywordtype">int</span> pos = 0;      
<a name="l00580"></a>00580       <span class="keywordtype">size_t</span> num_packables;
<a name="l00581"></a>00581       <a class="code" href="mpi__bindings_8h.html#a0ca041799a1675718d678bc1a7882b92">CMPI_Unpack</a>((<span class="keywordtype">void</span>*)&amp;buffer[0], buffer.size(), &amp;pos, &amp;num_packables, 1, <a class="code" href="mpi__utils_8h.html#aaae430420e25984e327a89b068e1582b">MPI_SIZE_T</a>, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583       packables.resize(num_packables);
<a name="l00584"></a>00584       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; packables.size(); i++) {
<a name="l00585"></a>00585         packables[i] = T::unpack((<span class="keywordtype">void</span>*)&amp;buffer[0], buffer.size(), &amp;pos, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00586"></a>00586       }
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="comment"></span>
<a name="l00590"></a>00590 <span class="comment">    ///</span>
<a name="l00591"></a>00591 <span class="comment">    /// Find the closest object in the medoids vector to the object passed in.</span>
<a name="l00592"></a>00592 <span class="comment">    /// Returns a pair of the closest medoid&#39;s id and its distance from the object.</span>
<a name="l00593"></a>00593 <span class="comment">    /// </span>
<a name="l00594"></a>00594 <span class="comment">    /// @param[in] object   Object to compare to medoids.</span>
<a name="l00595"></a>00595 <span class="comment">    /// @param[in] oid      ID of the object (need this so medoids prefer themselves as their own medoids).</span>
<a name="l00596"></a>00596 <span class="comment">    /// @param[in] medoids  Vector of medoids to find the closest from.</span>
<a name="l00597"></a>00597 <span class="comment">    /// @param[in] dmetric  Distance metric to assess closeness with.</span>
<a name="l00598"></a>00598 <span class="comment">    ///</span>
<a name="l00599"></a>00599 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;
<a name="l00600"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886">00600</a>     std::pair&lt;double, size_t&gt; <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(
<a name="l00601"></a>00601       <span class="keyword">const</span> T&amp; <span class="keywordtype">object</span>, <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> oid, <span class="keyword">const</span> std::vector&lt; <a class="code" href="structcluster_1_1id__pair.html" title="MPI-packable struct for an MPI-packable type plus its object id.">id_pair&lt;T&gt;</a> &gt;&amp; medoids, D dmetric
<a name="l00602"></a>00602     ) {
<a name="l00603"></a>00603       <span class="keywordtype">double</span> min_distance = DBL_MAX;
<a name="l00604"></a>00604       <span class="keywordtype">size_t</span> min_id = medoids.size();
<a name="l00605"></a>00605       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; medoids.size(); m++) {
<a name="l00606"></a>00606         <span class="keywordtype">double</span> d = dmetric(medoids[m].element, <span class="keywordtype">object</span>);
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (d &lt; min_distance || medoids[m].<span class="keywordtype">id</span> == oid) { <span class="comment">// prefer actual medoid as closest</span>
<a name="l00608"></a>00608           min_distance = d;
<a name="l00609"></a>00609           min_id = m;
<a name="l00610"></a>00610         }
<a name="l00611"></a>00611       }
<a name="l00612"></a>00612       <span class="keywordflow">return</span> std::make_pair(min_distance, min_id);
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   };
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 } <span class="comment">// Namespace cluster</span>
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 <span class="preprocessor">#endif // PAR_KMEDOIDS_H</span>
</pre></div></div>
</div>
<hr class="footer"/>
<a href="http://www.doxygen.org/">
    <img border="0" src="doxygen.png" align="left" style="margin-right:10px;margin-left:5px;"/>
</a>
<small>
<b>Muster</b>.
Copyright &copy; 2010, <a href="http://www.llnl.gov">Lawrence Livermore National Laboratory</a>,  LLNL-CODE-433662.<br>
Distribution of Muster and its documentation is subject to terms of the Muster <a href="http://github.com/tgamblin/muster/blob/master/LICENSE">LICENSE</a>.<br>
Generated on Mon Dec 20 2010 using <a href="http://www.doxygen.org/">Doxygen 1.7.2</a>
</small>

