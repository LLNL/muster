<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Muster: src/par_kmedoids.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>src/par_kmedoids.h</h1>  </div>
</div>
<div class="contents">
<a href="par__kmedoids_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">// Copyright (c) 2010, Lawrence Livermore National Security, LLC.  </span>
<a name="l00003"></a>00003 <span class="comment">// Produced at the Lawrence Livermore National Laboratory  </span>
<a name="l00004"></a>00004 <span class="comment">// Written by Todd Gamblin, tgamblin@llnl.gov.</span>
<a name="l00005"></a>00005 <span class="comment">// LLNL-CODE-433662</span>
<a name="l00006"></a>00006 <span class="comment">// All rights reserved.  </span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// This file is part of Muster. For details, see http://github.com/tgamblin/muster. </span>
<a name="l00009"></a>00009 <span class="comment">// Please also read the LICENSE file for further information.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">// Redistribution and use in source and binary forms, with or without modification, are</span>
<a name="l00012"></a>00012 <span class="comment">// permitted provided that the following conditions are met:</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">//  * Redistributions of source code must retain the above copyright notice, this list of</span>
<a name="l00015"></a>00015 <span class="comment">//    conditions and the disclaimer below.</span>
<a name="l00016"></a>00016 <span class="comment">//  * Redistributions in binary form must reproduce the above copyright notice, this list of</span>
<a name="l00017"></a>00017 <span class="comment">//    conditions and the disclaimer (as noted below) in the documentation and/or other materials</span>
<a name="l00018"></a>00018 <span class="comment">//    provided with the distribution.</span>
<a name="l00019"></a>00019 <span class="comment">//  * Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse</span>
<a name="l00020"></a>00020 <span class="comment">//    or promote products derived from this software without specific prior written permission.</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS</span>
<a name="l00023"></a>00023 <span class="comment">// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00024"></a>00024 <span class="comment">// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</span>
<a name="l00025"></a>00025 <span class="comment">// LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE</span>
<a name="l00026"></a>00026 <span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00027"></a>00027 <span class="comment">// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00028"></a>00028 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<a name="l00029"></a>00029 <span class="comment">// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<a name="l00030"></a>00030 <span class="comment">// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#ifndef PAR_KMEDOIDS_H</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#define PAR_KMEDOIDS_H</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;boost/iterator/permutation_iterator.hpp&gt;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;Timer.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="kmedoids_8h.html" title="Implementations of the classic clustering algorithms PAM and CLARA, from Finding Groups in Data...">kmedoids.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="multi__gather_8h.html" title="Asynchronous, some-to-some gather operation used by parallel clustering algorithms to simultaneously ...">multi_gather.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="trial_8h.html" title="Data structure representing a trial run of a partitioned clustering algorithm.">trial.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="id__pair_8h.html" title="MPI-packable, templated struct for shipping around an MPI-packable object plus the id of the process ...">id_pair.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="par__partition_8h.html" title="Distributed representation of a partitioning of a data set.">par_partition.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;stl_utils.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="bic_8h.html" title="Template function implementations of the Bayesian Information Criterion.">bic.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="mpi__bindings_8h.html" title="#defines for switching between MPI and PMPI bindings.">mpi_bindings.h</a>&quot;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">namespace </span>cluster {
<a name="l00059"></a>00059 
<a name="l00113"></a><a class="code" href="classcluster_1_1par__kmedoids.html">00113</a>   <span class="keyword">class </span><a class="code" href="classcluster_1_1par__kmedoids.html" title="This class implements the CAPEK and XCAPEK scalable parallel clustering algorithms.">par_kmedoids</a> : <span class="keyword">public</span> <a class="code" href="structcluster_1_1par__partition.html" title="par_partition represents a partitioning of a distributed data set.">par_partition</a> {
<a name="l00114"></a>00114   <span class="keyword">public</span>:
<a name="l00121"></a>00121     <a class="code" href="classcluster_1_1par__kmedoids.html#a7a44a5ee645ee45cb479d37e3d1c4e31" title="Constructs a parallel kmedoids object and seeds its random number generator.">par_kmedoids</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a> = MPI_COMM_WORLD);
<a name="l00122"></a>00122 
<a name="l00123"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a4a1cd2eabb5bc734250e034d7a658a58">00123</a>     <span class="keyword">virtual</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4a1cd2eabb5bc734250e034d7a658a58">~par_kmedoids</a>() { }
<a name="l00124"></a>00124 
<a name="l00126"></a>00126     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aefdef4bfd3bcbf2e1fd63cf7b3924615" title="Get the average dissimilarity of objects w/their medoids for the last run.">average_dissimilarity</a>();
<a name="l00127"></a>00127 
<a name="l00129"></a>00129     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a78a7d200bc68f11fc75d6a426f96a7da" title="BIC score for selected clustering.">bic_score</a>();
<a name="l00130"></a>00130 
<a name="l00135"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a05e1f5c528ed8d41479b6d81ec7874e4">00135</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a05e1f5c528ed8d41479b6d81ec7874e4" title="Sets max_reps, Max number of times to run PAM with each sampled dataset.">set_max_reps</a>(<span class="keywordtype">size_t</span> reps) { <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a> = reps; }
<a name="l00136"></a>00136 
<a name="l00140"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a08761f65d4e113dfcd70df17a176d853">00140</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a08761f65d4e113dfcd70df17a176d853" title="Max number of times to run PAM with each sampled dataset.">get_max_reps</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>; }
<a name="l00141"></a>00141     
<a name="l00146"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a82827f8d32b0003429a4c3c17af6a25e">00146</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a82827f8d32b0003429a4c3c17af6a25e" title="Sets init_size, baseline size for samples, added to 2*k.">set_init_size</a>(<span class="keywordtype">size_t</span> size) { <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a> = size; }
<a name="l00147"></a>00147     
<a name="l00151"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a31833400b7e60ff1c4cf21a5bcfbc225">00151</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a31833400b7e60ff1c4cf21a5bcfbc225" title="Baseline size for samples, added to 2*k.">get_init_size</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>; }
<a name="l00152"></a>00152 
<a name="l00156"></a>00156     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a419b9d3140b288429149fd13e3b59bf1" title="Set tolerance for convergence.">set_epsilon</a>(<span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00163"></a>00163     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00164"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7">00164</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(<a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a>&amp; trials, <span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, 
<a name="l00165"></a>00165                         std::vector&lt;<span class="keyword">typename</span> <a class="code" href="structcluster_1_1id__pair.html#a7377914a95a9724684cca5075f889ea2" title="Template typedef for declaring vectors of id_pair&amp;lt;T&amp;gt;">id_pair&lt;T&gt;::vector</a>&gt;&amp; all_medoids, MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>)
<a name="l00166"></a>00166     {
<a name="l00167"></a>00167       <span class="keywordtype">int</span> size, rank;
<a name="l00168"></a>00168       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(comm, &amp;size);
<a name="l00169"></a>00169       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(comm, &amp;rank);
<a name="l00170"></a>00170       
<a name="l00171"></a>00171       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; trials.<a class="code" href="classcluster_1_1trial__generator.html#ad3c044665f52e3f3b65f671625a070d4" title="whether there are trials remaining.">has_next</a>(); i++) {
<a name="l00172"></a>00172         <span class="keywordtype">int</span> my_k = -1;                        <span class="comment">// trial id for local run of kmedoids</span>
<a name="l00173"></a>00173         <span class="keywordtype">int</span> my_trial = -1;                    <span class="comment">// trial id for local run of kmedoids</span>
<a name="l00174"></a>00174         std::vector&lt;size_t&gt;  my_ids;          <span class="comment">// object ids for each of my_objects</span>
<a name="l00175"></a>00175         std::vector&lt;T&gt;       my_objects;      <span class="comment">// vector to hold local sample of objects for clustering.</span>
<a name="l00176"></a>00176         <a class="code" href="classcluster_1_1multi__gather.html" title="Asynchronous, some-to-some gather operation used by parallel clustering algorithms to simultaneously ...">multi_gather&lt;T&gt;</a>      <a class="code" href="structcluster_1_1par__partition.html#a02d94b5ae788fc7ac1a397875e8d4533" title="Collective operation.">gather</a>(comm);    <span class="comment">// simultaneous, asynchronous local gathers for collecting samples.</span>
<a name="l00177"></a>00177         
<a name="l00178"></a>00178         <span class="comment">// start gathers for each trial to aggregate samples to single worker processes.</span>
<a name="l00179"></a>00179         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> root=0; trials.<a class="code" href="classcluster_1_1trial__generator.html#ad3c044665f52e3f3b65f671625a070d4" title="whether there are trials remaining.">has_next</a>() &amp;&amp; root &lt; size; root++) {
<a name="l00180"></a>00180           <a class="code" href="structcluster_1_1trial.html" title="This struct represents parameters for a single trial run of kmedoids.">trial</a> cur_trial = trials.<a class="code" href="classcluster_1_1trial__generator.html#a7832cbc625558fb4856d5114581c3a64" title="return parameters for next trial">next</a>();    <span class="comment">// generate a trial descriptor</span>
<a name="l00181"></a>00181           
<a name="l00182"></a>00182           <span class="comment">// Generate a set of indices for members of this k-medoids trial</span>
<a name="l00183"></a>00183           std::vector&lt;size_t&gt; sample_ids;
<a name="l00184"></a>00184           boost::random_number_generator&lt;random_t&gt; rng(<a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2" title="Random number distribution to be used for samples.">random</a>);  <span class="comment">// Boost adaptor for STL RNG&#39;s</span>
<a name="l00185"></a>00185           <a class="code" href="namespacecluster.html#a5a49ac83447a427e107632127220ebc8" title="This is Knuth&amp;#39;s algorithm R for taking a sample of indices from 0 to numElements.">random_subset</a>(trials.<a class="code" href="classcluster_1_1trial__generator.html#a1ec0a2c32feae7df7b105b92b3838806" title="number of elements in the data set; determines maximum sample size.">num_objects</a>, cur_trial.<a class="code" href="structcluster_1_1trial.html#aecbfe89adcb57f51a2c4370c50acedbb">sample_size</a>, std::back_inserter(sample_ids), rng);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187           <span class="comment">// figure out where the sample objects live, ASSUME objects.size() objs per process.</span>
<a name="l00188"></a>00188           std::vector&lt;int&gt; sources;
<a name="l00189"></a>00189           std::transform(sample_ids.begin(), sample_ids.end(), std::back_inserter(sources),
<a name="l00190"></a>00190                          std::bind2nd(std::divides&lt;size_t&gt;(), objects.size()));
<a name="l00191"></a>00191           sources.erase(std::unique(sources.begin(), sources.end()), sources.end());
<a name="l00192"></a>00192 
<a name="l00193"></a>00193           <span class="comment">// make a permutation vector for the indices of the sampled *local* objects</span>
<a name="l00194"></a>00194           std::vector&lt;size_t&gt; sample_indices;
<a name="l00195"></a>00195           transform(std::lower_bound(sample_ids.begin(), sample_ids.end(), objects.size() * rank),
<a name="l00196"></a>00196                     std::lower_bound(sample_ids.begin(), sample_ids.end(), objects.size() * (rank + 1)),
<a name="l00197"></a>00197                     std::back_inserter(sample_indices),
<a name="l00198"></a>00198                     std::bind2nd(std::minus&lt;int&gt;(), objects.size() * rank));
<a name="l00199"></a>00199 
<a name="l00200"></a>00200           <span class="comment">// gather trial members to the current worker (root)</span>
<a name="l00201"></a>00201           gather.<a class="code" href="classcluster_1_1multi__gather.html#a24d640a945fc8cf40db8c4135025a0d4" title="Starts initial send and receive requests for this gather.">start</a>(boost::make_permutation_iterator(objects.begin(), sample_indices.begin()), 
<a name="l00202"></a>00202                        boost::make_permutation_iterator(objects.begin(), sample_indices.end()),
<a name="l00203"></a>00203                        sources.begin(), sources.end(), my_objects, root);
<a name="l00204"></a>00204           
<a name="l00205"></a>00205           <span class="comment">// record which trial to use locally and save the medoids there.</span>
<a name="l00206"></a>00206           <span class="keywordflow">if</span> (rank == root) {
<a name="l00207"></a>00207             my_k     = cur_trial.<a class="code" href="structcluster_1_1trial.html#a9389e4770ba454a2e14f870491495cb2">k</a>;
<a name="l00208"></a>00208             my_trial = trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>() - 1;
<a name="l00209"></a>00209             my_ids.swap(sample_ids);
<a name="l00210"></a>00210           }
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;StartGather&quot;</span>);
<a name="l00213"></a>00213         
<a name="l00214"></a>00214         <span class="comment">// finish all sample gathers.</span>
<a name="l00215"></a>00215         gather.<a class="code" href="classcluster_1_1multi__gather.html#a6dfe1abe0d1eb3ddc1ca081de98b5342">finish</a>();
<a name="l00216"></a>00216         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;FinishGather&quot;</span>);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         <span class="comment">// if we&#39;re a worker process (we were assigned a k and a trial number) then run PAM on the sample.</span>
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (my_k &gt;= 0) {
<a name="l00220"></a>00220           <a class="code" href="classcluster_1_1kmedoids.html" title="Implementations of the classic clustering algorithms PAM and CLARA, from Finding Groups in Data...">kmedoids</a> cluster;
<a name="l00221"></a>00221           cluster.<a class="code" href="classcluster_1_1kmedoids.html#a419b9d3140b288429149fd13e3b59bf1" title="Set tolerance for convergence.">set_epsilon</a>(<a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223           <a class="code" href="namespacecluster.html#a3da8b7c34d3e5089d88d0a8760a4d57c" title="Packed repersentation of symmetric dissimilarity matrix.">dissimilarity_matrix</a> mat;
<a name="l00224"></a>00224           <a class="code" href="namespacecluster.html#ac42a89b1657078539345f7ff233803cd" title="Computes a dissimilarity matrix from a vector of objects.">build_dissimilarity_matrix</a>(my_objects, dmetric, mat);
<a name="l00225"></a>00225           cluster.<a class="code" href="classcluster_1_1kmedoids.html#abb472d7a1325a47b8abde2af0509089c" title="Classic K-Medoids clustering, using the Partitioning-Around-Medoids (PAM) algorithm as described in K...">pam</a>(mat, my_k);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227           <span class="comment">// put this trial&#39;s medoids into its spot in the global medoids array.</span>
<a name="l00228"></a>00228           <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>.size(); m++) {
<a name="l00229"></a>00229             all_medoids[my_trial].push_back(
<a name="l00230"></a>00230               <a class="code" href="namespacecluster.html#a3e7c255cedb29a255f3907f9037d182a" title="Helper function for making arbitrary id_pairs with type inference.">make_id_pair</a>(my_objects[cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>[m]], my_ids[cluster.<a class="code" href="structcluster_1_1partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the index of the object that is the ith medoid.">medoid_ids</a>[m]]));
<a name="l00231"></a>00231           }
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;LocalCluster&quot;</span>);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <span class="comment">// once workers are done clustering, broadcast the medoids from each clustering </span>
<a name="l00236"></a>00236         <span class="comment">// so that all processes have the full all_medoids array.</span>
<a name="l00237"></a>00237         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> trial_id = i * size; trial_id &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); trial_id++) {
<a name="l00238"></a>00238           <a class="code" href="classcluster_1_1par__kmedoids.html#aa845135e44659fe4a70fc8e4992d98db" title="This function broadcasts a vector of packable objects on one process to all processes.">bcast_vector</a>(comm, all_medoids[trial_id], trial_id % size);
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;Broadcast&quot;</span>);
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00272"></a>00272     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00273"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a9e6466011d78034865dfcb0b15e33bf2">00273</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a9e6466011d78034865dfcb0b15e33bf2" title="This is the Clustering Algorithm with Parallel Extensions to K-Medoids (CAPEK).">capek</a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, <span class="keywordtype">size_t</span> k, std::vector&lt;T&gt; *medoids = NULL) 
<a name="l00274"></a>00274     {
<a name="l00275"></a>00275       <span class="keywordtype">int</span> size, rank;
<a name="l00276"></a>00276       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;size);
<a name="l00277"></a>00277       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;rank);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279       <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>); <span class="comment">// seed RN generator uniformly across ranks.</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281       <span class="comment">// fix things if k is greater than the number of elements, since we can&#39;t </span>
<a name="l00282"></a>00282       <span class="comment">// ever find that many clusters.</span>
<a name="l00283"></a>00283       <span class="keywordtype">size_t</span> num_objects = size * objects.size();
<a name="l00284"></a>00284       k = std::min(num_objects, k);
<a name="l00285"></a>00285       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;Init&quot;</span>);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287       <span class="comment">// do parallel work: farms out trials and broadcasts medoids from each trial to</span>
<a name="l00288"></a>00288       <span class="comment">// all processes.  On completion, medoids from all trials are in all_medoids vector.</span>
<a name="l00289"></a>00289       std::vector&lt;typename id_pair&lt;T&gt;::vector&gt; all_medoids(<a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>);
<a name="l00290"></a>00290       <a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a> trials(k, k, <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>, <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>, num_objects);
<a name="l00291"></a>00291       <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(trials, objects, dmetric, all_medoids, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293       <span class="comment">// Make two arrays to hold our closest medoids and their distance from our object</span>
<a name="l00294"></a>00294       std::vector&lt;double&gt; all_dissimilarities(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), 0.0);           <span class="comment">// dissimilarity sums</span>
<a name="l00295"></a>00295       std::vector&lt; std::vector&lt;medoid_id&gt; &gt; all_cluster_ids(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());  <span class="comment">// local nearest medoid ids</span>
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       <span class="comment">// Go through all the trials again, and for each of them, find the closest </span>
<a name="l00298"></a>00298       <span class="comment">// medoid to this process&#39;s objects and sum the dissimilarities</span>
<a name="l00299"></a>00299       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00300"></a>00300         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> o=0; o &lt; objects.size(); o++) {
<a name="l00301"></a>00301           <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> global_oid = rank + o;
<a name="l00302"></a>00302           std::pair&lt;double, size_t&gt; closest = <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(objects[o], global_oid, all_medoids[i], dmetric);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304           all_dissimilarities[i]  += closest.first;
<a name="l00305"></a>00305           all_cluster_ids[i].push_back(closest.second);
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307       }
<a name="l00308"></a>00308       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;FindMinima&quot;</span>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310       <span class="comment">// Sum up all the min dissimilarities.  We do a Reduce/Bcast instead of an Allreduce</span>
<a name="l00311"></a>00311       <span class="comment">// to avoid FP error and guarantee that sums is the same across all processors.</span>
<a name="l00312"></a>00312       std::vector&lt;double&gt; sums(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());         <span class="comment">// destination vectors for reduction.</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissimilarities[0],  &amp;sums[0], trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00315"></a>00315       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums[0],  trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00316"></a>00316       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;GlobalSums&quot;</span>);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318       <span class="comment">// find minmum global dissimilarity among all trials.</span>
<a name="l00319"></a>00319       std::vector&lt;double&gt;::iterator min_sum = std::min_element(sums.begin(), sums.end());
<a name="l00320"></a>00320       <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a> = *min_sum;
<a name="l00321"></a>00321       <span class="keywordtype">size_t</span> best = (min_sum - sums.begin());  <span class="comment">// index of best trial.</span>
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324       <span class="comment">// Finally set up the partition to correspond to trial with best dissimilarity found</span>
<a name="l00325"></a>00325       <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.resize(all_medoids[best].size());
<a name="l00326"></a>00326       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00327"></a>00327         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][i].id;
<a name="l00328"></a>00328       }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330       <span class="comment">// Make an indirection vector from the unsorted to sorted medoids</span>
<a name="l00331"></a>00331       std::vector&lt;size_t&gt; mapping(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00332"></a>00332       std::generate(mapping.begin(), mapping.end(), sequence());
<a name="l00333"></a>00333       std::sort(mapping.begin(), mapping.end(), indexed_lt(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>));
<a name="l00334"></a>00334       invert(mapping);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336       <span class="comment">// set up local cluster ids, medoids, and medoid_ids with the sorted mapping.</span>
<a name="l00337"></a>00337       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00338"></a>00338         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][mapping[i]].id;
<a name="l00339"></a>00339       }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341       <span class="comment">// swap in the cluster ids with the best BIC score.</span>
<a name="l00342"></a>00342       <a class="code" href="structcluster_1_1par__partition.html#afd520c040af2b60ff8950a86fcc370f9" title="Global cluster ids for local objects.">cluster_ids</a>.swap(all_cluster_ids[best]);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344       <span class="comment">// if the caller wanted a copy of the medoids, copy them into the dstination array.</span>
<a name="l00345"></a>00345       <span class="keywordflow">if</span> (medoids) {
<a name="l00346"></a>00346         medoids-&gt;resize(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00347"></a>00347         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00348"></a>00348           (*medoids)[i] = all_medoids[best][mapping[i]].element;
<a name="l00349"></a>00349         }
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;BicScore&quot;</span>);
<a name="l00353"></a>00353     }    
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     
<a name="l00385"></a>00385     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
<a name="l00386"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a6d10b9b98495838ee9425932c6529855">00386</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6d10b9b98495838ee9425932c6529855" title="K-agnostic version of capek().">xcapek</a>(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; objects, D dmetric, <span class="keywordtype">size_t</span> max_k, <span class="keywordtype">size_t</span> dimensionality,
<a name="l00387"></a>00387                   std::vector&lt;T&gt; *medoids = NULL) 
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389       <span class="keywordtype">int</span> size, rank;
<a name="l00390"></a>00390       <a class="code" href="mpi__bindings_8h.html#a3380ea537971aff2c18b28b3cdd2fc33">CMPI_Comm_size</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;size);
<a name="l00391"></a>00391       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, &amp;rank);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(<a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>); <span class="comment">// seed RN generator uniformly across ranks.</span>
<a name="l00394"></a>00394 
<a name="l00395"></a>00395       <span class="comment">// fix things if k is greater than the number of elements, since we can&#39;t </span>
<a name="l00396"></a>00396       <span class="comment">// ever find that many clusters.</span>
<a name="l00397"></a>00397       <span class="keywordtype">size_t</span> num_objects = size * objects.size();
<a name="l00398"></a>00398       max_k = std::min(num_objects, max_k);
<a name="l00399"></a>00399       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;Init&quot;</span>);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401       std::vector&lt;typename id_pair&lt;T&gt;::vector&gt; all_medoids(max_k * <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>);
<a name="l00402"></a>00402       <a class="code" href="classcluster_1_1trial__generator.html" title="Class to generate a set of trials for clustering.">trial_generator</a> trials(max_k, max_reps, <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>, num_objects);
<a name="l00403"></a>00403       <a class="code" href="classcluster_1_1par__kmedoids.html#a850aeb878057a5dee35ce4be4006c7b7" title="Farms out trials of PAM to worker processes then collects medoids from all trials to all processors...">run_pam_trials</a>(trials, objects, dmetric, all_medoids, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405       <span class="comment">// Make two arrays to hold our closest medoids and their distance from our object</span>
<a name="l00406"></a>00406       std::vector&lt;double&gt; all_dissimilarities(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), 0.0);           <span class="comment">// dissimilarity sums</span>
<a name="l00407"></a>00407       std::vector&lt; std::vector&lt;medoid_id&gt; &gt; all_cluster_ids(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());  <span class="comment">// local nearest medoid ids</span>
<a name="l00408"></a>00408 
<a name="l00409"></a>00409       std::vector&lt;double&gt; all_dissim2;      <span class="comment">// dissimilarity sums squared</span>
<a name="l00410"></a>00410       std::vector&lt;size_t&gt; cluster_sizes;    <span class="comment">// sizes of clusters in each trial</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412       <span class="comment">// Go through all the trials again, and for each of them, find the closest </span>
<a name="l00413"></a>00413       <span class="comment">// medoid to this process&#39;s objects and sum the squared dissimilarities</span>
<a name="l00414"></a>00414       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00415"></a>00415         <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_medoids = all_medoids[i].size();
<a name="l00416"></a>00416         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; num_medoids; m++) {
<a name="l00417"></a>00417           all_dissim2.push_back(0.0);
<a name="l00418"></a>00418           cluster_sizes.push_back(0);
<a name="l00419"></a>00419         }
<a name="l00420"></a>00420         <span class="keywordtype">double</span> *dissim2 = &amp;all_dissim2[all_dissim2.size() - num_medoids];
<a name="l00421"></a>00421         <span class="keywordtype">size_t</span> *sizes   = &amp;cluster_sizes[cluster_sizes.size() - num_medoids];
<a name="l00422"></a>00422         
<a name="l00423"></a>00423         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> o=0; o &lt; objects.size(); o++) {
<a name="l00424"></a>00424           <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> global_oid = rank + o;
<a name="l00425"></a>00425           std::pair&lt;double, size_t&gt; closest = <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(objects[o], global_oid, all_medoids[i], dmetric);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427           all_dissimilarities[i]  += closest.first;
<a name="l00428"></a>00428           dissim2[closest.second] += closest.first * closest.first;
<a name="l00429"></a>00429           sizes[closest.second]   += 1;
<a name="l00430"></a>00430           all_cluster_ids[i].push_back(closest.second);
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432       }
<a name="l00433"></a>00433       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;FindMinima&quot;</span>);
<a name="l00434"></a>00434       
<a name="l00435"></a>00435 
<a name="l00436"></a>00436       <span class="comment">// Sum up all the min dissimilarities.  We do a Reduce/Bcast instead of an Allreduce</span>
<a name="l00437"></a>00437       <span class="comment">// to avoid FP error and guarantee that sums is the same across all processors.</span>
<a name="l00438"></a>00438       std::vector&lt;double&gt; sums(trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>());         <span class="comment">// destination vectors for reduction.</span>
<a name="l00439"></a>00439       std::vector&lt;double&gt; sums2(all_dissim2.size());
<a name="l00440"></a>00440       std::vector&lt;size_t&gt; sizes(cluster_sizes.size());
<a name="l00441"></a>00441 
<a name="l00442"></a>00442       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissimilarities[0],  &amp;sums[0], trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00443"></a>00443       <a class="code" href="mpi__bindings_8h.html#a5db6d803f8f562e2b69c3ebc22282741">CMPI_Reduce</a>(&amp;all_dissim2[0], &amp;sums2[0], sums2.size(), MPI_DOUBLE, MPI_SUM, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00444"></a>00444       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums[0],  trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00445"></a>00445       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;sums2[0], sums2.size(), MPI_DOUBLE, 0, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00446"></a>00446       <a class="code" href="mpi__bindings_8h.html#a268656dc03a973bb2f30567f65010984">CMPI_Allreduce</a>(&amp;cluster_sizes[0], &amp;sizes[0], sizes.size(), MPI_SIZE_T, MPI_SUM, <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00447"></a>00447       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;GlobalSums&quot;</span>);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449       <span class="comment">// find minmum global dissimilarity among all trials.</span>
<a name="l00450"></a>00450       std::vector&lt;double&gt;::iterator min_sum = std::min_element(sums.begin(), sums.end());
<a name="l00451"></a>00451       <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a> = *min_sum;
<a name="l00452"></a>00452       <span class="keywordtype">size_t</span> best = (min_sum - sums.begin());  <span class="comment">// index of best trial.</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454       <span class="comment">// locally calculate the BIC for each trial</span>
<a name="l00455"></a>00455       <span class="keywordtype">size_t</span> best_trial = 0;
<a name="l00456"></a>00456       <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>    = -DBL_MAX;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458       <span class="keywordtype">size_t</span> trial_offset = 0;  <span class="comment">// offset into sizes array</span>
<a name="l00459"></a>00459       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; trials.<a class="code" href="classcluster_1_1trial__generator.html#a22a9772c09848d90444dda7fefa4d9ce" title="return iterations so far.">count</a>(); i++) {
<a name="l00460"></a>00460         <span class="keywordtype">size_t</span> k = all_medoids[i].size();
<a name="l00461"></a>00461         <span class="keywordtype">double</span> cur_bic = <a class="code" href="namespacecluster.html#af654c630dfe169d9f005f16956ed293f" title="Directly computes the BIC from a partition object based on the cluster centroids and the number of cl...">bic</a>(k, &amp;sizes[trial_offset], &amp;sums2[trial_offset], dimensionality);
<a name="l00462"></a>00462         <span class="keywordflow">if</span> (cur_bic &gt; <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>) {
<a name="l00463"></a>00463           best_trial     = i;
<a name="l00464"></a>00464           <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a> = cur_bic;
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466         trial_offset += k;
<a name="l00467"></a>00467       }
<a name="l00468"></a>00468       
<a name="l00469"></a>00469       best = best_trial;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471       <span class="comment">// Finally set up the partition to correspond to best trial found.</span>
<a name="l00472"></a>00472       <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.resize(all_medoids[best].size());
<a name="l00473"></a>00473       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00474"></a>00474         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][i].id;
<a name="l00475"></a>00475       }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477       <span class="comment">// Make an indirection vector from the unsorted to sorted medoids.</span>
<a name="l00478"></a>00478       std::vector&lt;size_t&gt; mapping(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00479"></a>00479       std::generate(mapping.begin(), mapping.end(), sequence());
<a name="l00480"></a>00480       std::sort(mapping.begin(), mapping.end(), indexed_lt(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>));
<a name="l00481"></a>00481       invert(mapping);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="comment">// set up local cluster ids, medoids, and medoid_ids with the sorted mapping.</span>
<a name="l00484"></a>00484       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00485"></a>00485         <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>[i] = all_medoids[best][mapping[i]].id;
<a name="l00486"></a>00486       }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488       <span class="comment">// swap in the cluster ids with the best BIC score.</span>
<a name="l00489"></a>00489       <a class="code" href="structcluster_1_1par__partition.html#afd520c040af2b60ff8950a86fcc370f9" title="Global cluster ids for local objects.">cluster_ids</a>.swap(all_cluster_ids[best]);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491       <span class="comment">// if the user wanted a copy of the medoids, copy them into the dstination array.</span>
<a name="l00492"></a>00492       <span class="keywordflow">if</span> (medoids) {
<a name="l00493"></a>00493         medoids-&gt;resize(<a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size());
<a name="l00494"></a>00494         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="structcluster_1_1par__partition.html#a673ab926a3012f7aa057dd85b3bb84f2" title="Gives the object id for the ith medoid. This object may not be local.">medoid_ids</a>.size(); i++) {
<a name="l00495"></a>00495           (*medoids)[i] = all_medoids[best][mapping[i]].element;
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497       }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499       <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>.record(<span class="stringliteral">&quot;BicScore&quot;</span>);
<a name="l00500"></a>00500       <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>;
<a name="l00501"></a>00501     }    
<a name="l00502"></a>00502     
<a name="l00504"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a41466ea324bfff7bec48d504692e135b">00504</a>     <span class="keyword">const</span> Timer&amp; <a class="code" href="classcluster_1_1par__kmedoids.html#a41466ea324bfff7bec48d504692e135b" title="Get the Timer with info on the last run of either capek() or xcapek().">get_timer</a>() { <span class="keywordflow">return</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>; }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keyword">protected</span>:
<a name="l00507"></a><a class="code" href="classcluster_1_1par__kmedoids.html#ac5c6013aecf88eb9e9a3011a2158f867">00507</a>     <span class="keyword">typedef</span> boost::mt19937 random_t;   
<a name="l00508"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2">00508</a>     <a class="code" href="classcluster_1_1par__kmedoids.html#ac5c6013aecf88eb9e9a3011a2158f867" title="Type for random number generator used here.">random_t</a> <a class="code" href="classcluster_1_1par__kmedoids.html#a514010490e8b49a79d1d39b58b1310e2" title="Random number distribution to be used for samples.">random</a>;                   
<a name="l00509"></a>00509     
<a name="l00510"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220">00510</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a752062b45d39866c3b974523a888d220" title="Total dissimilarity bt/w objects and medoids for last clustering.">total_dissimilarity</a>;   
<a name="l00511"></a><a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74">00511</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aabff7136babe56b9a165152e0b24fa74" title="BIC score for the clustering found.">best_bic_score</a>;        
<a name="l00512"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876">00512</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a6aad23523234e617409dbf31687f6876" title="baseline size for samples">init_size</a>;             
<a name="l00513"></a><a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3">00513</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcluster_1_1par__kmedoids.html#af4c641bc801fd71d691835566187f4b3" title="Max repetitions of trials for a particular k.">max_reps</a>;              
<a name="l00514"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7">00514</a>     <span class="keywordtype">double</span> <a class="code" href="classcluster_1_1par__kmedoids.html#a4904cc82627458fdf6672ccc0b2802c7" title="Tolerance for convergence tests in kmedoids PAM runs.">epsilon</a>;               
<a name="l00515"></a>00515 
<a name="l00516"></a><a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4">00516</a>     Timer <a class="code" href="classcluster_1_1par__kmedoids.html#aaf7e0389622e8f7b78393ee10d8e93a4" title="Performance timer.">timer</a>;                  
<a name="l00517"></a>00517 
<a name="l00522"></a>00522     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aa77d09e372e07cc7db51b3f9000348c8" title="Seeds random number generators across all processes with the same number, taken from the time in micr...">seed_random_uniform</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>);
<a name="l00523"></a>00523 
<a name="l00532"></a>00532     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00533"></a><a class="code" href="classcluster_1_1par__kmedoids.html#aa845135e44659fe4a70fc8e4992d98db">00533</a>     <span class="keywordtype">void</span> <a class="code" href="classcluster_1_1par__kmedoids.html#aa845135e44659fe4a70fc8e4992d98db" title="This function broadcasts a vector of packable objects on one process to all processes.">bcast_vector</a>(MPI_Comm <a class="code" href="structcluster_1_1par__partition.html#ab048c6f9fcbcfaa57ce68b00263dbebe" title="Communicator, the processes of which this partition divides.">comm</a>, std::vector&lt;T&gt;&amp; medoids, <span class="keywordtype">int</span> root) {
<a name="l00534"></a>00534       <span class="keywordtype">int</span> rank;
<a name="l00535"></a>00535       <a class="code" href="mpi__bindings_8h.html#afcd8a04b2f0cc1a64889c76fd572c530">CMPI_Comm_rank</a>(comm, &amp;rank);
<a name="l00536"></a>00536 
<a name="l00537"></a>00537       <span class="comment">// figure out size of packed buffer</span>
<a name="l00538"></a>00538       <span class="keywordtype">int</span> packed_size=0;
<a name="l00539"></a>00539       <span class="keywordflow">if</span> (rank == root) {
<a name="l00540"></a>00540         packed_size += <a class="code" href="mpi__bindings_8h.html#a19f4c652252a22e96d5238908f6cb6d4">cmpi_packed_size</a>(1, MPI_SIZE_T, comm);   <span class="comment">// num medoids for trial.</span>
<a name="l00541"></a>00541         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; medoids.size(); i++) {         <span class="comment">// size of medoids.</span>
<a name="l00542"></a>00542           packed_size += medoids[i].packed_size(comm);
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544       }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546       <span class="comment">// broadcast size and allocate receive buffer.</span>
<a name="l00547"></a>00547       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;packed_size, 1, MPI_INT, root, comm);
<a name="l00548"></a>00548       <span class="keywordtype">char</span> packed_buffer[packed_size];
<a name="l00549"></a>00549 
<a name="l00550"></a>00550       <span class="comment">// pack buffer with medoid objects</span>
<a name="l00551"></a>00551       <span class="keywordflow">if</span> (rank == root) {
<a name="l00552"></a>00552         <span class="keywordtype">int</span> pos = 0;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         <span class="keywordtype">size_t</span> num_medoids = medoids.size();
<a name="l00555"></a>00555         <a class="code" href="mpi__bindings_8h.html#abc3639efb607f9c5918a5a79765d389c">CMPI_Pack</a>(&amp;num_medoids, 1, MPI_SIZE_T, packed_buffer, packed_size, &amp;pos, comm);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; num_medoids; i++) {
<a name="l00558"></a>00558           medoids[i].pack(packed_buffer, packed_size, &amp;pos, comm);
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       <a class="code" href="mpi__bindings_8h.html#ac354c89365eeda2157f0f3dae755bcf7">CMPI_Bcast</a>(&amp;packed_buffer, packed_size, MPI_PACKED, root, comm);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564       <span class="comment">// unpack broadcast medoids.</span>
<a name="l00565"></a>00565       <span class="keywordflow">if</span> (rank != root) {
<a name="l00566"></a>00566         <span class="keywordtype">int</span> pos = 0;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568         <span class="keywordtype">size_t</span> num_medoids;
<a name="l00569"></a>00569         <a class="code" href="mpi__bindings_8h.html#a0ca041799a1675718d678bc1a7882b92">CMPI_Unpack</a>(packed_buffer, packed_size, &amp;pos, &amp;num_medoids, 1, MPI_SIZE_T, comm);
<a name="l00570"></a>00570         medoids.resize(num_medoids);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; medoids.size(); i++) {
<a name="l00573"></a>00573           medoids[i] = T::unpack(packed_buffer, packed_size, &amp;pos, comm);
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575       }
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 
<a name="l00587"></a>00587     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;
<a name="l00588"></a><a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886">00588</a>     std::pair&lt;double, size_t&gt; <a class="code" href="classcluster_1_1par__kmedoids.html#a315db34b268616a19223f5b29f8e6886" title="Find the closest object in the medoids vector to the object passed in.">closest_medoid</a>(
<a name="l00589"></a>00589       <span class="keyword">const</span> T&amp; <span class="keywordtype">object</span>, <a class="code" href="namespacecluster.html#abe52518c0b3d1e6319b0b994ed58a315" title="More descriptive type for object index.">object_id</a> oid, <span class="keyword">const</span> std::vector&lt; <a class="code" href="structcluster_1_1id__pair.html" title="MPI-packable struct for an MPI-packable type plus its object id.">id_pair&lt;T&gt;</a> &gt;&amp; medoids, D dmetric
<a name="l00590"></a>00590     ) {
<a name="l00591"></a>00591       <span class="keywordtype">double</span> min_distance = DBL_MAX;
<a name="l00592"></a>00592       <span class="keywordtype">size_t</span> min_id = medoids.size();
<a name="l00593"></a>00593       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m=0; m &lt; medoids.size(); m++) {
<a name="l00594"></a>00594         <span class="keywordtype">double</span> d = dmetric(medoids[m].element, <span class="keywordtype">object</span>);
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (d &lt; min_distance || medoids[m].<span class="keywordtype">id</span> == oid) { <span class="comment">// prefer actual medoid as closest</span>
<a name="l00596"></a>00596           min_distance = d;
<a name="l00597"></a>00597           min_id = m;
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599       }
<a name="l00600"></a>00600       <span class="keywordflow">return</span> std::make_pair(min_distance, min_id);
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   };
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 } <span class="comment">// Namespace cluster</span>
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="preprocessor">#endif // PAR_KMEDOIDS_H</span>
</pre></div></div>
</div>
<hr class="footer"/>
<a href="http://www.doxygen.org/">
    <img border="0" src="doxygen.png" align="left" style="margin-right:10px;margin-left:5px;"/>
</a>
<small>
<b>Muster</b>.
Copyright &copy; 2010, <a href="http://www.llnl.gov">Lawrence Livermore National Laboratory</a>,  LLNL-CODE-433662.<br>
Distribution of the Muster documentation is subject to terms of the Muster <a href="http://github.com/tgamblin/muster/blob/master/LICENSE">LICENSE</a>.<br>
Generated on Wed Oct 13 2010 using <a href="http://www.doxygen.org/">Doxygen 1.7.1</a>
</small>

